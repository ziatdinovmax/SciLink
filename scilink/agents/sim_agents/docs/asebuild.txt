# Content of ase/build:

Directory structure:
└── build/
    ├── __init__.py
    ├── attach.py
    ├── bulk.py
    ├── connected.py
    ├── general_surface.py
    ├── molecule.py
    ├── niggli.py
    ├── ribbon.py
    ├── root.py
    ├── rotate.py
    ├── supercells.py
    ├── surface.py
    ├── surfaces_with_termination.py
    ├── tools.py
    └── tube.py

================================================
File: __init__.py
================================================
# fmt: off

from ase.build.bulk import bulk
from ase.build.connected import (
    connected_atoms,
    connected_indices,
    separate,
    split_bond,
)
from ase.build.general_surface import surface
from ase.build.molecule import molecule
from ase.build.ribbon import graphene_nanoribbon
from ase.build.root import (
    bcc111_root,
    fcc111_root,
    hcp0001_root,
    root_surface,
    root_surface_analysis,
)
from ase.build.rotate import minimize_rotation_and_translation
from ase.build.supercells import (
    find_optimal_cell_shape,
    get_deviation_from_optimal_cell_shape,
    make_supercell,
)
from ase.build.surface import (
    add_adsorbate,
    add_vacuum,
    bcc100,
    bcc110,
    bcc111,
    diamond100,
    diamond111,
    fcc100,
    fcc110,
    fcc111,
    fcc211,
    graphene,
    hcp0001,
    hcp10m10,
    mx2,
)
from ase.build.tools import (
    cut,
    minimize_tilt,
    niggli_reduce,
    rotate,
    sort,
    stack,
)
from ase.build.tube import nanotube

__all__ = ['minimize_rotation_and_translation',
           'add_adsorbate', 'add_vacuum',
           'bcc100', 'bcc110', 'bcc111',
           'diamond100', 'diamond111',
           'fcc100', 'fcc110', 'fcc111', 'fcc211',
           'hcp0001', 'hcp10m10', 'mx2', 'graphene',
           'bulk', 'surface', 'molecule',
           'hcp0001_root', 'fcc111_root', 'bcc111_root',
           'root_surface', 'root_surface_analysis',
           'nanotube', 'graphene_nanoribbon',
           'cut', 'stack', 'sort', 'minimize_tilt', 'niggli_reduce',
           'rotate',
           'connected_atoms', 'connected_indices',
           'separate', 'split_bond',
           'get_deviation_from_optimal_cell_shape',
           'find_optimal_cell_shape',
           'make_supercell']



================================================
File: attach.py
================================================
# fmt: off

import numpy as np

from ase.geometry import get_distances
from ase.parallel import broadcast, world


def random_unit_vector(rng):
    """Random unit vector equally distributed on the sphere

    Parameter
    ---------
    rng: random number generator object
    """
    ct = -1 + 2 * rng.random()
    phi = 2 * np.pi * rng.random()
    st = np.sqrt(1 - ct**2)
    return np.array([st * np.cos(phi), st * np.sin(phi), ct])


def nearest(atoms1, atoms2, cell=None, pbc=None):
    """Return indices of nearest atoms"""
    p1 = atoms1.get_positions()
    p2 = atoms2.get_positions()
    vd_aac, d2_aa = get_distances(p1, p2, cell, pbc)
    i1, i2 = np.argwhere(d2_aa == d2_aa.min())[0]
    return i1, i2, vd_aac[i1, i2]


def attach(atoms1, atoms2, distance, direction=(1, 0, 0),
           maxiter=50, accuracy=1e-5):
    """Attach two structures

    Parameters
    ----------
    atoms1: Atoms
      cell and pbc of this object are used
    atoms2: Atoms
    distance: float
      minimal distance (Angstrom)
    direction: unit vector (3 floats)
      relative direction between center of masses
    maxiter: int
      maximal number of iterations to get required distance, default 100
    accuracy: float
      required accuracy for minimal distance (Angstrom), default 1e-5

    Returns
    -------
    Joined structure as an atoms object.
    """
    atoms = atoms1.copy()
    atoms2 = atoms2.copy()

    direction = np.array(direction, dtype=float)
    direction /= np.linalg.norm(direction)
    assert len(direction) == 3
    dist2 = distance**2

    _i1, _i2, dv_c = nearest(atoms, atoms2, atoms.cell, atoms.pbc)

    for _ in range(maxiter):
        dv2 = (dv_c**2).sum()

        vcost = np.dot(dv_c, direction)
        a = np.sqrt(max(0, dist2 - dv2 + vcost**2))
        move = a - vcost
        if abs(move) < accuracy:
            atoms += atoms2
            return atoms

        # we need to move
        atoms2.translate(direction * move)
        _i1, _i2, dv_c = nearest(atoms, atoms2, atoms.cell, atoms.pbc)

    raise RuntimeError('attach did not converge')


def attach_randomly(atoms1, atoms2, distance,
                    rng=np.random):
    """Randomly attach two structures with a given minimal distance

    Parameters
    ----------
    atoms1: Atoms object
    atoms2: Atoms object
    distance: float
      Required distance
    rng: random number generator object
      defaults to np.random.RandomState()

    Returns
    -------
    Joined structure as an atoms object.
    """
    atoms2 = atoms2.copy()
    atoms2.rotate('x', random_unit_vector(rng),
                  center=atoms2.get_center_of_mass())
    return attach(atoms1, atoms2, distance,
                  direction=random_unit_vector(rng))


def attach_randomly_and_broadcast(atoms1, atoms2, distance,
                                  rng=np.random,
                                  comm=world):
    """Randomly attach two structures with a given minimal distance
      and ensure that these are distributed.

    Parameters
    ----------
    atoms1: Atoms object
    atoms2: Atoms object
    distance: float
      Required distance
    rng: random number generator object
      defaults to np.random.RandomState()
    comm: communicator to distribute
      Communicator to distribute the structure, default: world

    Returns
    -------
    Joined structure as an atoms object.
    """
    if comm.rank == 0:
        joined = attach_randomly(atoms1, atoms2, distance, rng)
        broadcast(joined, 0, comm=comm)
    else:
        joined = broadcast(None, 0, comm)
    return joined



================================================
File: bulk.py
================================================
# fmt: off

"""Build crystalline systems"""
from math import sqrt
from typing import Any

from ase.atoms import Atoms
from ase.data import atomic_numbers, chemical_symbols, reference_states
from ase.symbols import string2symbols
from ase.utils import plural


def incompatible_cell(*, want, have):
    return RuntimeError(f'Cannot create {want} cell for {have} structure')


def bulk(
    name: str,
    crystalstructure: str = None,
    a: float = None,
    b: float = None,
    c: float = None,
    *,
    alpha: float = None,
    covera: float = None,
    u: float = None,
    orthorhombic: bool = False,
    cubic: bool = False,
    basis=None,
) -> Atoms:
    """Creating bulk systems.

    Crystal structure and lattice constant(s) will be guessed if not
    provided.

    name: str
        Chemical symbol or symbols as in 'MgO' or 'NaCl'.
    crystalstructure: str
        Must be one of sc, fcc, bcc, tetragonal, bct, hcp, rhombohedral,
        orthorhombic, mcl, diamond, zincblende, rocksalt, cesiumchloride,
        fluorite or wurtzite.
    a: float
        Lattice constant.
    b: float
        Lattice constant.  If only a and b is given, b will be interpreted
        as c instead.
    c: float
        Lattice constant.
    alpha: float
        Angle in degrees for rhombohedral lattice.
    covera: float
        c/a ratio used for hcp.  Default is ideal ratio: sqrt(8/3).
    u: float
        Internal coordinate for Wurtzite structure.
    orthorhombic: bool
        Construct orthorhombic unit cell instead of primitive cell
        which is the default.
    cubic: bool
        Construct cubic unit cell if possible.
    """

    if c is None and b is not None:
        # If user passes (a, b) positionally, we want it as (a, c) instead:
        c, b = b, c

    if covera is not None and c is not None:
        raise ValueError("Don't specify both c and c/a!")

    xref = ''
    ref: Any = {}

    if name in chemical_symbols:  # single element
        atomic_number = atomic_numbers[name]
        ref = reference_states[atomic_number]
        if ref is None:
            ref = {}  # easier to 'get' things from empty dictionary than None
        else:
            xref = ref['symmetry']

        if crystalstructure is None:
            # `ref` requires `basis` but not given and not pre-defined
            if basis is None and 'basis' in ref and ref['basis'] is None:
                raise ValueError('This structure requires an atomic basis')
            if xref == 'cubic':
                # P and Mn are listed as 'cubic' but the lattice constants
                # are 7 and 9.  They must be something other than simple cubic
                # then. We used to just return the cubic one but that must
                # have been wrong somehow.  --askhl
                raise ValueError(
                    f'The reference structure of {name} is not implemented')

    # Mapping of name to number of atoms in primitive cell.
    structures = {'sc': 1, 'fcc': 1, 'bcc': 1,
                  'tetragonal': 1,
                  'bct': 1,
                  'hcp': 1,
                  'rhombohedral': 1,
                  'orthorhombic': 1,
                  'mcl': 1,
                  'diamond': 1,
                  'zincblende': 2, 'rocksalt': 2, 'cesiumchloride': 2,
                  'fluorite': 3, 'wurtzite': 2}

    if crystalstructure is None:
        crystalstructure = xref
        if crystalstructure not in structures:
            raise ValueError(f'No suitable reference data for bulk {name}.'
                             f'  Reference data: {ref}')

    magmom_per_atom = None
    if crystalstructure == xref:
        magmom_per_atom = ref.get('magmom_per_atom')

    if crystalstructure not in structures:
        raise ValueError(f'Unknown structure: {crystalstructure}.')

    # Check name:
    natoms = len(string2symbols(name))
    natoms0 = structures[crystalstructure]
    if natoms != natoms0:
        raise ValueError('Please specify {} for {} and not {}'
                         .format(plural(natoms0, 'atom'),
                                 crystalstructure, natoms))

    if alpha is None:
        alpha = ref.get('alpha')

    if a is None:
        if xref != crystalstructure:
            raise ValueError('You need to specify the lattice constant.')
        if 'a' in ref:
            a = ref['a']
        else:
            raise KeyError(f'No reference lattice parameter "a" for "{name}"')

    if b is None:
        bovera = ref.get('b/a')
        if bovera is not None and a is not None:
            b = bovera * a

    if crystalstructure in ['hcp', 'wurtzite']:
        if c is not None:
            covera = c / a
        elif covera is None:
            if xref == crystalstructure:
                covera = ref['c/a']
            else:
                covera = sqrt(8 / 3)

    if covera is None:
        covera = ref.get('c/a')
        if c is None and covera is not None:
            c = covera * a

    if crystalstructure == 'bct':
        from ase.lattice import BCT
        if basis is None:
            basis = ref.get('basis')
        if basis is not None:
            natoms = len(basis)
        lat = BCT(a=a, c=c)
        atoms = Atoms([name] * natoms, cell=lat.tocell(), pbc=True,
                      scaled_positions=basis)
    elif crystalstructure == 'rhombohedral':
        atoms = _build_rhl(name, a, alpha, basis)
    elif crystalstructure == 'orthorhombic':
        atoms = Atoms(name, cell=[a, b, c], pbc=True)
    elif orthorhombic:
        atoms = _orthorhombic_bulk(name, crystalstructure, a, covera, u)
    elif cubic:
        atoms = _cubic_bulk(name, crystalstructure, a)
    else:
        atoms = _primitive_bulk(name, crystalstructure, a, covera, u)

    if magmom_per_atom is not None:
        magmoms = [magmom_per_atom] * len(atoms)
        atoms.set_initial_magnetic_moments(magmoms)

    if cubic or orthorhombic:
        assert atoms.cell.orthorhombic

    return atoms


def _build_rhl(name, a, alpha, basis):
    from ase.lattice import RHL
    lat = RHL(a, alpha)
    cell = lat.tocell()
    if basis is None:
        # RHL: Given by A&M as scaled coordinates "x" of cell.sum(0):
        basis_x = reference_states[atomic_numbers[name]]['basis_x']
        basis = basis_x[:, None].repeat(3, axis=1)
    natoms = len(basis)
    return Atoms([name] * natoms, cell=cell, scaled_positions=basis, pbc=True)


def _orthorhombic_bulk(name, crystalstructure, a, covera=None, u=None):
    if crystalstructure in ('sc', 'bcc', 'cesiumchloride'):
        atoms = _cubic_bulk(name, crystalstructure, a)
    elif crystalstructure == 'fcc':
        b = a / sqrt(2)
        cell = (b, b, a)
        scaled_positions = ((0.0, 0.0, 0.0), (0.5, 0.5, 0.5))
        atoms = Atoms(2 * name, cell=cell, scaled_positions=scaled_positions)
    elif crystalstructure == 'hcp':
        cell = (a, a * sqrt(3), covera * a)
        scaled_positions = [
            (0.0, 0 / 6, 0.0),
            (0.5, 3 / 6, 0.0),
            (0.5, 1 / 6, 0.5),
            (0.0, 4 / 6, 0.5),
        ]
        atoms = Atoms(4 * name, cell=cell, scaled_positions=scaled_positions)
    elif crystalstructure == 'diamond':
        b = a / sqrt(2)
        cell = (b, b, a)
        scaled_positions = [
            (0.0, 0.0, 0.0), (0.5, 0.0, 0.25),
            (0.5, 0.5, 0.5), (0.0, 0.5, 0.75),
        ]
        atoms = Atoms(4 * name, cell=cell, scaled_positions=scaled_positions)
    elif crystalstructure == 'rocksalt':
        b = a / sqrt(2)
        cell = (b, b, a)
        scaled_positions = [
            (0.0, 0.0, 0.0), (0.5, 0.5, 0.0),
            (0.5, 0.5, 0.5), (0.0, 0.0, 0.5),
        ]
        atoms = Atoms(2 * name, cell=cell, scaled_positions=scaled_positions)
    elif crystalstructure == 'zincblende':
        symbol0, symbol1 = string2symbols(name)
        atoms = _orthorhombic_bulk(symbol0, 'diamond', a)
        atoms.symbols[[1, 3]] = symbol1
    elif crystalstructure == 'wurtzite':
        cell = (a, a * sqrt(3), covera * a)
        u = u or 0.25 + 1 / 3 / covera**2
        scaled_positions = [
            (0.0, 0 / 6, 0.0), (0.0, 2 / 6, 0.5 - u),
            (0.0, 2 / 6, 0.5), (0.0, 0 / 6, 1.0 - u),
            (0.5, 3 / 6, 0.0), (0.5, 5 / 6, 0.5 - u),
            (0.5, 5 / 6, 0.5), (0.5, 3 / 6, 1.0 - u),
        ]
        atoms = Atoms(4 * name, cell=cell, scaled_positions=scaled_positions)
    else:
        raise incompatible_cell(want='orthorhombic', have=crystalstructure)

    atoms.pbc = True

    return atoms


def _cubic_bulk(name: str, crystalstructure: str, a: float) -> Atoms:
    cell = (a, a, a)
    if crystalstructure == 'sc':
        atoms = Atoms(name, cell=cell)
    elif crystalstructure == 'fcc':
        scaled_positions = [
            (0.0, 0.0, 0.0),
            (0.0, 0.5, 0.5),
            (0.5, 0.0, 0.5),
            (0.5, 0.5, 0.0),
        ]
        atoms = Atoms(4 * name, cell=cell, scaled_positions=scaled_positions)
    elif crystalstructure == 'bcc':
        scaled_positions = [
            (0.0, 0.0, 0.0),
            (0.5, 0.5, 0.5),
        ]
        atoms = Atoms(2 * name, cell=cell, scaled_positions=scaled_positions)
    elif crystalstructure == 'diamond':
        scaled_positions = [
            (0.0, 0.0, 0.0), (0.25, 0.25, 0.25),
            (0.0, 0.5, 0.5), (0.25, 0.75, 0.75),
            (0.5, 0.0, 0.5), (0.75, 0.25, 0.75),
            (0.5, 0.5, 0.0), (0.75, 0.75, 0.25),
        ]
        atoms = Atoms(8 * name, cell=cell, scaled_positions=scaled_positions)
    elif crystalstructure == 'cesiumchloride':
        symbol0, symbol1 = string2symbols(name)
        atoms = _cubic_bulk(symbol0, 'bcc', a)
        atoms.symbols[[1]] = symbol1
    elif crystalstructure == 'zincblende':
        symbol0, symbol1 = string2symbols(name)
        atoms = _cubic_bulk(symbol0, 'diamond', a)
        atoms.symbols[[1, 3, 5, 7]] = symbol1
    elif crystalstructure == 'rocksalt':
        scaled_positions = [
            (0.0, 0.0, 0.0), (0.5, 0.0, 0.0),
            (0.0, 0.5, 0.5), (0.5, 0.5, 0.5),
            (0.5, 0.0, 0.5), (0.0, 0.0, 0.5),
            (0.5, 0.5, 0.0), (0.0, 0.5, 0.0),
        ]
        atoms = Atoms(4 * name, cell=cell, scaled_positions=scaled_positions)
    elif crystalstructure == 'fluorite':
        scaled_positions = [
            (0.00, 0.00, 0.00), (0.25, 0.25, 0.25), (0.75, 0.75, 0.75),
            (0.00, 0.50, 0.50), (0.25, 0.75, 0.75), (0.75, 0.25, 0.25),
            (0.50, 0.00, 0.50), (0.75, 0.25, 0.75), (0.25, 0.75, 0.25),
            (0.50, 0.50, 0.00), (0.75, 0.75, 0.25), (0.25, 0.25, 0.75),
        ]
        atoms = Atoms(4 * name, cell=cell, scaled_positions=scaled_positions)
    else:
        raise incompatible_cell(want='cubic', have=crystalstructure)

    atoms.pbc = True

    return atoms


def _primitive_bulk(name, crystalstructure, a, covera=None, u=None):
    if crystalstructure == 'sc':
        atoms = Atoms(name, cell=(a, a, a))
    elif crystalstructure == 'fcc':
        b = 0.5 * a
        cell = ((0, b, b), (b, 0, b), (b, b, 0))
        atoms = Atoms(name, cell=cell)
    elif crystalstructure == 'bcc':
        b = 0.5 * a
        cell = ((-b, b, b), (b, -b, b), (b, b, -b))
        atoms = Atoms(name, cell=cell)
    elif crystalstructure == 'hcp':
        c = covera * a
        cell = ((a, 0, 0), (-0.5 * a, 0.5 * sqrt(3) * a, 0), (0, 0, c))
        scaled_positions = [
            (0 / 3, 0 / 3, 0.0),
            (1 / 3, 2 / 3, 0.5),
        ]
        atoms = Atoms(2 * name, cell=cell, scaled_positions=scaled_positions)
    elif crystalstructure == 'diamond':
        atoms = \
            _primitive_bulk(name, 'fcc', a) + \
            _primitive_bulk(name, 'fcc', a)
        atoms.positions[1, :] += 0.25 * a
    elif crystalstructure == 'rocksalt':
        symbol0, symbol1 = string2symbols(name)
        atoms = \
            _primitive_bulk(symbol0, 'fcc', a) + \
            _primitive_bulk(symbol1, 'fcc', a)
        atoms.positions[1, 0] += 0.5 * a
    elif crystalstructure == 'cesiumchloride':
        symbol0, symbol1 = string2symbols(name)
        atoms = \
            _primitive_bulk(symbol0, 'sc', a) + \
            _primitive_bulk(symbol1, 'sc', a)
        atoms.positions[1, :] += 0.5 * a
    elif crystalstructure == 'zincblende':
        symbol0, symbol1 = string2symbols(name)
        atoms = \
            _primitive_bulk(symbol0, 'fcc', a) + \
            _primitive_bulk(symbol1, 'fcc', a)
        atoms.positions[1, :] += 0.25 * a
    elif crystalstructure == 'fluorite':
        symbol0, symbol1, symbol2 = string2symbols(name)
        atoms = \
            _primitive_bulk(symbol0, 'fcc', a) + \
            _primitive_bulk(symbol1, 'fcc', a) + \
            _primitive_bulk(symbol2, 'fcc', a)
        atoms.positions[1, :] += 0.25 * a
        atoms.positions[2, :] += 0.75 * a
    elif crystalstructure == 'wurtzite':
        c = covera * a
        cell = ((a, 0, 0), (-0.5 * a, 0.5 * sqrt(3) * a, 0), (0, 0, c))
        u = u or 0.25 + 1 / 3 / covera**2
        scaled_positions = [
            (0 / 3, 0 / 3, 0.0), (1 / 3, 2 / 3, 0.5 - u),
            (1 / 3, 2 / 3, 0.5), (0 / 3, 0 / 3, 1.0 - u),
        ]
        atoms = Atoms(2 * name, cell=cell, scaled_positions=scaled_positions)
    else:
        raise incompatible_cell(want='primitive', have=crystalstructure)

    atoms.pbc = True

    return atoms



================================================
File: connected.py
================================================
from ase.atoms import Atoms
from ase.data import covalent_radii
from ase.neighborlist import NeighborList


def connected_atoms(atoms, index, dmax=None, scale=1.5):
    """Find all atoms connected to atoms[index] and return them."""
    return atoms[connected_indices(atoms, index, dmax, scale)]


def connected_indices(atoms, index, dmax=None, scale=1.5):
    """Find atoms connected to atoms[index] and return their indices.

    If dmax is not None:
    Atoms are defined to be connected if they are nearer than dmax
    to each other.

    If dmax is None:
    Atoms are defined to be connected if they are nearer than the
    sum of their covalent radii * scale to each other.

    """
    if index < 0:
        index = len(atoms) + index

    # set neighbor lists
    if dmax is None:
        # define neighbors according to covalent radii
        radii = scale * covalent_radii[atoms.get_atomic_numbers()]
    else:
        # define neighbors according to distance
        radii = [0.5 * dmax] * len(atoms)
    nl = NeighborList(radii, skin=0, self_interaction=False, bothways=True)
    nl.update(atoms)

    connected = [index] + list(nl.get_neighbors(index)[0])
    isolated = False
    while not isolated:
        isolated = True
        for i in connected:
            for j in nl.get_neighbors(i)[0]:
                if j not in connected:
                    connected.append(j)
                    isolated = False

    return connected


def separate(atoms, **kwargs):
    """Split atoms into separated entities

    Returns:
      List of Atoms object that connected_indices calls connected.
    """
    indices = list(range(len(atoms)))

    separated = []
    while indices:
        my_indcs = connected_indices(atoms, indices[0], **kwargs)
        separated.append(Atoms(cell=atoms.cell, pbc=atoms.pbc))
        for i in my_indcs:
            separated[-1].append(atoms[i])
            del indices[indices.index(i)]

    return separated


def split_bond(atoms, index1, index2, **kwargs):
    """Split atoms by a bond specified by indices

    index1: index of first atom
    index2: index of second atom
    kwargs: kwargs transferred to connected_atoms

    Returns two Atoms objects
    """
    assert index1 != index2
    if index2 > index1:
        shift = 0, 1
    else:
        shift = 1, 0

    atoms_copy = atoms.copy()
    del atoms_copy[index2]
    atoms1 = connected_atoms(atoms_copy, index1 - shift[0], **kwargs)

    atoms_copy = atoms.copy()
    del atoms_copy[index1]
    atoms2 = connected_atoms(atoms_copy, index2 - shift[1], **kwargs)

    return atoms1, atoms2



================================================
File: general_surface.py
================================================
# fmt: off

from math import gcd

import numpy as np
from numpy.linalg import norm, solve

from ase.build import bulk
from ase.build.surface import create_tags


def surface(lattice, indices, layers, vacuum=None, tol=1e-10, periodic=False):
    """Create surface from a given lattice and Miller indices.

    lattice: Atoms object or str
        Bulk lattice structure of alloy or pure metal.  Note that the
        unit-cell must be the conventional cell - not the primitive cell.
        One can also give the chemical symbol as a string, in which case the
        correct bulk lattice will be generated automatically.
    indices: sequence of three int
        Surface normal in Miller indices (h,k,l).
    layers: int
        Number of equivalent layers of the slab.
    vacuum: float
        Amount of vacuum added on both sides of the slab.
    periodic: bool
        Whether the surface is periodic in the normal to the surface
    """

    indices = np.asarray(indices)

    if indices.shape != (3,) or not indices.any() or indices.dtype != int:
        raise ValueError(f'{indices} is an invalid surface type')

    if isinstance(lattice, str):
        lattice = bulk(lattice, cubic=True)

    h, k, l = indices  # noqa (E741, the variable l)
    h0, k0, l0 = (indices == 0)

    if h0 and k0 or h0 and l0 or k0 and l0:  # if two indices are zero
        if not h0:
            c1, c2, c3 = [(0, 1, 0), (0, 0, 1), (1, 0, 0)]
        if not k0:
            c1, c2, c3 = [(0, 0, 1), (1, 0, 0), (0, 1, 0)]
        if not l0:
            c1, c2, c3 = [(1, 0, 0), (0, 1, 0), (0, 0, 1)]
    else:
        p, q = ext_gcd(k, l)
        a1, a2, a3 = lattice.cell

        # constants describing the dot product of basis c1 and c2:
        # dot(c1,c2) = k1+i*k2, i in Z
        k1 = np.dot(p * (k * a1 - h * a2) + q * (l * a1 - h * a3),
                    l * a2 - k * a3)
        k2 = np.dot(l * (k * a1 - h * a2) - k * (l * a1 - h * a3),
                    l * a2 - k * a3)

        if abs(k2) > tol:
            i = -int(round(k1 / k2))  # i corresponding to the optimal basis
            p, q = p + i * l, q - i * k

        a, b = ext_gcd(p * k + q * l, h)

        c1 = (p * k + q * l, -p * h, -q * h)
        c2 = np.array((0, l, -k)) // abs(gcd(l, k))
        c3 = (b, a * p, a * q)

    surf = build(lattice, np.array([c1, c2, c3]), layers, tol, periodic)
    if vacuum is not None:
        surf.center(vacuum=vacuum, axis=2)
    return surf


def build(lattice, basis, layers, tol, periodic):
    surf = lattice.copy()
    scaled = solve(basis.T, surf.get_scaled_positions().T).T
    scaled -= np.floor(scaled + tol)
    surf.set_scaled_positions(scaled)
    surf.set_cell(np.dot(basis, surf.cell), scale_atoms=True)
    surf *= (1, 1, layers)
    surf.set_tags(create_tags((1, len(lattice), layers)))

    a1, a2, a3 = surf.cell
    surf.set_cell([a1, a2,
                   np.cross(a1, a2) * np.dot(a3, np.cross(a1, a2)) /
                   norm(np.cross(a1, a2))**2])

    # Change unit cell to have the x-axis parallel with a surface vector
    # and z perpendicular to the surface:
    a1, a2, a3 = surf.cell
    surf.set_cell([(norm(a1), 0, 0),
                   (np.dot(a1, a2) / norm(a1),
                    np.sqrt(norm(a2)**2 - (np.dot(a1, a2) / norm(a1))**2), 0),
                   (0, 0, norm(a3))],
                  scale_atoms=True)

    surf.pbc = (True, True, periodic)

    # Move atoms into the unit cell:
    scaled = surf.get_scaled_positions()
    scaled[:, :2] %= 1
    surf.set_scaled_positions(scaled)

    if not periodic:
        surf.cell[2] = 0.0

    return surf


def ext_gcd(a, b):
    if b == 0:
        return 1, 0
    elif a % b == 0:
        return 0, 1
    else:
        x, y = ext_gcd(b, a % b)
        return y, x - y * (a // b)



================================================
File: molecule.py
================================================
# fmt: off

from ase.atoms import Atoms
from ase.collections import g2


def molecule(name, vacuum=None, **kwargs):
    """Create an atomic structure from a database.

    This is a helper function to easily create molecules from the g2 and
    extra databases.

    Parameters
    ----------
    name : str
        Name of the molecule to build.
    vacuum : float, optional
        Amount of vacuum to pad the molecule with on all sides.
    Additional keyword arguments (kwargs) can be supplied, which are passed
    to ase.Atoms.

    Returns
    -------
    ase.atoms.Atoms
        An ASE Atoms object corresponding to the specified molecule.

    Notes
    -----
    To see a list of allowed names, try:

    >>> from ase.collections import g2
    >>> print(g2.names)  #doctest:+NORMALIZE_WHITESPACE
        ['PH3', 'P2', 'CH3CHO', 'H2COH', 'CS', 'OCHCHO', 'C3H9C', 'CH3COF',
        'CH3CH2OCH3', 'HCOOH', 'HCCl3', 'HOCl', 'H2', 'SH2', 'C2H2',
        'C4H4NH', 'CH3SCH3', 'SiH2_s3B1d', 'CH3SH', 'CH3CO', 'CO', 'ClF3',
        'SiH4', 'C2H6CHOH', 'CH2NHCH2', 'isobutene', 'HCO', 'bicyclobutane',
        'LiF', 'Si', 'C2H6', 'CN', 'ClNO', 'S', 'SiF4', 'H3CNH2',
        'methylenecyclopropane', 'CH3CH2OH', 'F', 'NaCl', 'CH3Cl',
        'CH3SiH3', 'AlF3', 'C2H3', 'ClF', 'PF3', 'PH2', 'CH3CN',
        'cyclobutene', 'CH3ONO', 'SiH3', 'C3H6_D3h', 'CO2', 'NO',
        'trans-butane', 'H2CCHCl', 'LiH', 'NH2', 'CH', 'CH2OCH2',
        'C6H6', 'CH3CONH2', 'cyclobutane', 'H2CCHCN', 'butadiene', 'C',
        'H2CO', 'CH3COOH', 'HCF3', 'CH3S', 'CS2', 'SiH2_s1A1d', 'C4H4S',
        'N2H4', 'OH', 'CH3OCH3', 'C5H5N', 'H2O', 'HCl', 'CH2_s1A1d',
        'CH3CH2SH', 'CH3NO2', 'Cl', 'Be', 'BCl3', 'C4H4O', 'Al', 'CH3O',
        'CH3OH', 'C3H7Cl', 'isobutane', 'Na', 'CCl4', 'CH3CH2O', 'H2CCHF',
        'C3H7', 'CH3', 'O3', 'P', 'C2H4', 'NCCN', 'S2', 'AlCl3', 'SiCl4',
        'SiO', 'C3H4_D2d', 'H', 'COF2', '2-butyne', 'C2H5', 'BF3', 'N2O',
        'F2O', 'SO2', 'H2CCl2', 'CF3CN', 'HCN', 'C2H6NH', 'OCS', 'B', 'ClO',
        'C3H8', 'HF', 'O2', 'SO', 'NH', 'C2F4', 'NF3', 'CH2_s3B1d',
        'CH3CH2Cl', 'CH3COCl', 'NH3', 'C3H9N', 'CF4', 'C3H6_Cs', 'Si2H6',
        'HCOOCH3', 'O', 'CCH', 'N', 'Si2', 'C2H6SO', 'C5H8', 'H2CF2', 'Li2',
        'CH2SCH2', 'C2Cl4', 'C3H4_C3v', 'CH3COCH3', 'F2', 'CH4', 'SH',
        'H2CCO', 'CH3CH2NH2', 'Li', 'N2', 'Cl2', 'H2O2', 'Na2', 'BeH',
        'C3H4_C2v', 'NO2']
    >>> from ase.build.molecule import extra
    >>> print(extra.keys())  #doctest:+NORMALIZE_WHITESPACE
        dict_keys(['Be2', 'C7NH5', 'BDA', 'biphenyl', 'C60'])

    Examples
    --------
    >>> from ase.build import molecule
    >>> atoms = molecule('H2O')

    """
    if name in extra:
        kwargs.update(extra[name])
        mol = Atoms(**kwargs)
    else:
        mol = g2[name]
        if kwargs:
            mol = Atoms(mol, **kwargs)
    if vacuum is not None:
        mol.center(vacuum=vacuum)
    return mol


extra = {
    'Be2': {
        'symbols': 'BeBe',
        'positions': [[0, 0, 1.0106],
                      [0, 0, -1.0106]]},
    'C7NH5': {
        'symbols': 'C7NH5',
        'positions': [[-1.593581, -1.142601, 0.],
                      [-2.235542, 0.095555, 0.],
                      [-0.204885, -1.210726, 0.],
                      [0.549645, -0.025355, 0.],
                      [1.976332, -0.085321, 0.],
                      [-0.099258, 1.220706, 0.],
                      [-1.488628, 1.273345, 0.],
                      [3.136871, -0.128138, 0.],
                      [-2.177996, -2.060896, 0.],
                      [-3.323594, 0.141242, 0.],
                      [0.301694, -2.173705, 0.],
                      [0.488716, 2.136782, 0.],
                      [-1.987765, 2.240495, 0.]]},
    'BDA': {
        # 1,4-Benzodiamine
        # aka p-Aminoaniline; p-Benzenediamine; p-Diaminobenzene;
        #     p-Phenylenediamine; Paraphenylen-diamine
        # PBE-gpaw relaxed
        'symbols': 'C6H4N2H4',
        'positions': [[0.004212, 1.406347, 0.061073],
                      [1.193490, 0.687096, 0.029481],
                      [1.190824, -0.690400, -0.028344],
                      [0.000295, -1.406191, -0.059503],
                      [-1.186974, -0.685668, -0.045413],
                      [-1.185376, 0.690203, 0.009452],
                      [2.147124, 1.219997, 0.064477],
                      [2.141593, -1.227477, -0.054266],
                      [-2.138408, -1.222814, -0.095050],
                      [-2.137740, 1.226930, 0.023036],
                      [-0.006314, 2.776024, 0.186278],
                      [-0.007340, -2.777839, -0.159936],
                      [0.844710, -3.256543, 0.110098],
                      [-0.854965, -3.253324, 0.130125],
                      [0.845826, 3.267270, -0.055549],
                      [-0.854666, 3.254654, -0.092676]]},
    'biphenyl': {
        # PBE-gpaw relaxed
        'symbols': 'C6H5C6H5',
        'positions': [[-0.74081, -0.00000, -0.00003],
                      [-1.46261, -1.20370, -0.00993],
                      [-2.85531, -1.20350, -0.00663],
                      [-3.55761, -0.00000, -0.00003],
                      [-2.85531, 1.20350, 0.00667],
                      [-1.46261, 1.20370, 0.00997],
                      [-0.92071, -2.14850, 0.00967],
                      [-3.38981, -2.15110, -0.00083],
                      [-4.64571, -0.00000, -0.00003],
                      [-3.38981, 2.15110, 0.00077],
                      [-0.92071, 2.14850, -0.00963],
                      [3.55849, -0.00000, -0.00003],
                      [2.85509, -0.86640, -0.83553],
                      [1.46289, -0.87000, -0.83153],
                      [0.73969, -0.00000, -0.00003],
                      [1.46289, 0.87000, 0.83157],
                      [2.85509, 0.86640, 0.83547],
                      [4.64659, -0.00000, -0.00003],
                      [3.39189, -1.53770, -1.50253],
                      [0.91869, -1.53310, -1.50263],
                      [0.91869, 1.53310, 1.50267],
                      [3.39189, 1.53770, 1.50257]]},
    'C60': {
        # Buckminsterfullerene, I*h symm.
        # The Buckyball has two degrees of freedom, the C-C bond, and the
        # C=C bond. This is an LDA-gpaw relaxed structure with bond lengths
        # 1.437 and 1.385.
        # Experimentally, the two bond lengths are 1.45 and 1.40 Angstrom.
        'symbols': 'C60',
        'positions': [[2.2101953, 0.5866631, 2.6669504],
                      [3.1076393, 0.1577008, 1.6300286],
                      [1.3284430, -0.3158939, 3.2363232],
                      [3.0908709, -1.1585005, 1.2014240],
                      [3.1879245, -1.4574599, -0.1997005],
                      [3.2214623, 1.2230966, 0.6739440],
                      [3.3161210, 0.9351586, -0.6765151],
                      [3.2984981, -0.4301142, -1.1204138],
                      [-0.4480842, 1.3591484, 3.2081020],
                      [0.4672056, 2.2949830, 2.6175264],
                      [-0.0256575, 0.0764219, 3.5086259],
                      [1.7727917, 1.9176584, 2.3529691],
                      [2.3954623, 2.3095689, 1.1189539],
                      [-0.2610195, 3.0820935, 1.6623117],
                      [0.3407726, 3.4592388, 0.4745968],
                      [1.6951171, 3.0692446, 0.1976623],
                      [-2.1258394, -0.8458853, 2.6700963],
                      [-2.5620990, 0.4855202, 2.3531715],
                      [-0.8781521, -1.0461985, 3.2367302],
                      [-1.7415096, 1.5679963, 2.6197333],
                      [-1.6262468, 2.6357030, 1.6641811],
                      [-3.2984810, 0.4301871, 1.1204208],
                      [-3.1879469, 1.4573895, 0.1996030],
                      [-2.3360261, 2.5813627, 0.4760912],
                      [-0.5005210, -2.9797771, 1.7940308],
                      [-1.7944338, -2.7729087, 1.2047891],
                      [-0.0514245, -2.1328841, 2.7938830],
                      [-2.5891471, -1.7225828, 1.6329715],
                      [-3.3160705, -0.9350636, 0.6765268],
                      [-1.6951919, -3.0692581, -0.1976564],
                      [-2.3954901, -2.3096853, -1.1189862],
                      [-3.2214182, -1.2231835, -0.6739581],
                      [2.1758234, -2.0946263, 1.7922529],
                      [1.7118619, -2.9749681, 0.7557198],
                      [1.3130656, -1.6829416, 2.7943892],
                      [0.3959024, -3.4051395, 0.7557638],
                      [-0.3408219, -3.4591883, -0.4745610],
                      [2.3360057, -2.5814499, -0.4761050],
                      [1.6263757, -2.6357349, -1.6642309],
                      [0.2611352, -3.0821271, -1.6622618],
                      [-2.2100844, -0.5868636, -2.6670300],
                      [-1.7726970, -1.9178969, -2.3530466],
                      [-0.4670723, -2.2950509, -2.6175105],
                      [-1.3283500, 0.3157683, -3.2362375],
                      [-2.1759882, 2.0945383, -1.7923294],
                      [-3.0909663, 1.1583472, -1.2015749],
                      [-3.1076090, -0.1578453, -1.6301627],
                      [-1.3131365, 1.6828292, -2.7943639],
                      [0.5003224, 2.9799637, -1.7940203],
                      [-0.3961148, 3.4052817, -0.7557272],
                      [-1.7120629, 2.9749122, -0.7557988],
                      [0.0512824, 2.1329478, -2.7937450],
                      [2.1258630, 0.8460809, -2.6700534],
                      [2.5891853, 1.7227742, -1.6329562],
                      [1.7943010, 2.7730684, -1.2048262],
                      [0.8781323, 1.0463514, -3.2365313],
                      [0.4482452, -1.3591061, -3.2080510],
                      [1.7416948, -1.5679557, -2.6197714],
                      [2.5621724, -0.4853529, -2.3532026],
                      [0.0257904, -0.0763567, -3.5084446]]}}



================================================
File: niggli.py
================================================
# fmt: off

import numpy as np


def cellvector_products(cell):
    cell = _pad_nonpbc(cell)
    g0 = np.empty(6, dtype=float)
    g0[0] = cell[0] @ cell[0]
    g0[1] = cell[1] @ cell[1]
    g0[2] = cell[2] @ cell[2]
    g0[3] = 2 * (cell[1] @ cell[2])
    g0[4] = 2 * (cell[2] @ cell[0])
    g0[5] = 2 * (cell[0] @ cell[1])
    return g0


def _pad_nonpbc(cell):
    # Add "infinitely long" lattice vectors for non-periodic directions,
    # perpendicular to the periodic ones.
    maxlen = max(cell.lengths())
    mask = cell.any(1)
    cell = cell.complete()
    cell[~mask] *= 2 * maxlen
    return cell


def niggli_reduce_cell(cell, epsfactor=None):
    from ase.cell import Cell

    cell = Cell.new(cell)
    npbc = cell.rank

    if epsfactor is None:
        epsfactor = 1e-5

    vol_normalization_exponent = 1 if npbc == 0 else 1 / npbc
    vol_normalization = cell.complete().volume**vol_normalization_exponent
    eps = epsfactor * vol_normalization

    g0 = cellvector_products(cell)
    g, C = _niggli_reduce(g0, eps)

    abc = np.sqrt(g[:3])
    # Prevent division by zero e.g. for cell==zeros((3, 3)):
    abcprod = max(abc.prod(), 1e-100)
    cosangles = abc * g[3:] / (2 * abcprod)
    angles = 180 * np.arccos(cosangles) / np.pi

    # Non-periodic directions have artificial infinitely long lattice vectors.
    # We re-zero their lengths before returning:
    abc[npbc:] = 0.0

    newcell = Cell.fromcellpar(np.concatenate([abc, angles]))

    newcell[npbc:] = 0.0
    return newcell, C


def lmn_to_ijk(lmn):
    if lmn.prod() == 1:
        ijk = lmn.copy()
        for idx in range(3):
            if ijk[idx] == 0:
                ijk[idx] = 1
    else:
        ijk = np.ones(3, dtype=int)
        if np.any(lmn != -1):
            r = None
            for idx in range(3):
                if lmn[idx] == 1:
                    ijk[idx] = -1
                elif lmn[idx] == 0:
                    r = idx
            if ijk.prod() == -1:
                ijk[r] = -1
    return ijk


def _niggli_reduce(g0, eps):
    I3 = np.eye(3, dtype=int)
    I6 = np.eye(6, dtype=int)

    C = I3.copy()
    D = I6.copy()

    g = D @ g0

    def lt(x, y, eps=eps):
        return x < y - eps

    def gt(x, y, eps=eps):
        return lt(y, x, eps)

    def eq(x, y, eps=eps):
        return not (lt(x, y, eps) or gt(x, y, eps))

    for _ in range(10000):
        if (gt(g[0], g[1])
                or (eq(g[0], g[1]) and gt(abs(g[3]), abs(g[4])))):
            C = C @ (-I3[[1, 0, 2]])
            D = I6[[1, 0, 2, 4, 3, 5]] @ D
            g = D @ g0
            continue
        elif (gt(g[1], g[2])
                or (eq(g[1], g[2]) and gt(abs(g[4]), abs(g[5])))):
            C = C @ (-I3[[0, 2, 1]])
            D = I6[[0, 2, 1, 3, 5, 4]] @ D
            g = D @ g0
            continue

        lmn = np.array(gt(g[3:], 0, eps=eps / 2), dtype=int)
        lmn -= np.array(lt(g[3:], 0, eps=eps / 2), dtype=int)

        ijk = lmn_to_ijk(lmn)

        C *= ijk[np.newaxis]

        D[3] *= ijk[1] * ijk[2]
        D[4] *= ijk[0] * ijk[2]
        D[5] *= ijk[0] * ijk[1]
        g = D @ g0

        if (gt(abs(g[3]), g[1])
                or (eq(g[3], g[1]) and lt(2 * g[4], g[5]))
                or (eq(g[3], -g[1]) and lt(g[5], 0))):
            s = int(np.sign(g[3]))

            A = I3.copy()
            A[1, 2] = -s
            C = C @ A

            B = I6.copy()
            B[2, 1] = 1
            B[2, 3] = -s
            B[3, 1] = -2 * s
            B[4, 5] = -s
            D = B @ D
            g = D @ g0
        elif (gt(abs(g[4]), g[0])
                or (eq(g[4], g[0]) and lt(2 * g[3], g[5]))
                or (eq(g[4], -g[0]) and lt(g[5], 0))):
            s = int(np.sign(g[4]))

            A = I3.copy()
            A[0, 2] = -s
            C = C @ A

            B = I6.copy()
            B[2, 0] = 1
            B[2, 4] = -s
            B[3, 5] = -s
            B[4, 0] = -2 * s
            D = B @ D
            g = D @ g0
        elif (gt(abs(g[5]), g[0])
                or (eq(g[5], g[0]) and lt(2 * g[3], g[4]))
                or (eq(g[5], -g[0]) and lt(g[4], 0))):
            s = int(np.sign(g[5]))

            A = I3.copy()
            A[0, 1] = -s
            C = C @ A

            B = I6.copy()
            B[1, 0] = 1
            B[1, 5] = -s
            B[3, 4] = -s
            B[5, 0] = -2 * s
            D = B @ D
            g = D @ g0
        elif (lt(g[[0, 1, 3, 4, 5]].sum(), 0)
                or (eq(g[[0, 1, 3, 4, 5]].sum(), 0)
                    and gt(2 * (g[0] + g[4]) + g[5], 0))):
            A = I3.copy()
            A[:, 2] = 1
            C = C @ A

            B = I6.copy()
            B[2, :] = 1
            B[3, 1] = 2
            B[3, 5] = 1
            B[4, 0] = 2
            B[4, 5] = 1
            D = B @ D
            g = D @ g0
        else:
            break
    else:
        raise RuntimeError('Niggli reduction not done in 10000 steps!\n'
                           'g={}\n'
                           'operation={}'
                           .format(g.tolist(), C.tolist()))

    return g, C



================================================
File: ribbon.py
================================================
# fmt: off

from math import sqrt

import numpy as np

from ase.atoms import Atoms


def graphene_nanoribbon(n, m, type='zigzag', saturated=False, C_H=1.09,
                        C_C=1.42, vacuum=None, magnetic=False, initial_mag=1.12,
                        sheet=False, main_element='C', saturate_element='H'):
    """Create a graphene nanoribbon.

    Creates a graphene nanoribbon in the x-z plane, with the nanoribbon
    running along the z axis.

    Parameters:

    n: int
        The width of the nanoribbon.  For armchair nanoribbons, this
        n may be half-integer to repeat by half a cell.
    m: int
        The length of the nanoribbon.
    type: str
        The orientation of the ribbon.  Must be either 'zigzag'
        or 'armchair'.
    saturated: bool
        If true, hydrogen atoms are placed along the edge.
    C_H: float
        Carbon-hydrogen bond length.  Default: 1.09 Angstrom.
    C_C: float
        Carbon-carbon bond length.  Default: 1.42 Angstrom.
    vacuum: None (default) or float
        Amount of vacuum added to non-periodic directions, if present.
    magnetic: bool
        Make the edges magnetic.
    initial_mag: float
        Magnitude of magnetic moment if magnetic.
    sheet: bool
        If true, make an infinite sheet instead of a ribbon (default: False)
    """

    if m % 1 != 0:
        raise ValueError('m must be integer')
    if type == 'zigzag' and n % 1 != 0:
        raise ValueError('n must be an integer for zigzag ribbons')

    b = sqrt(3) * C_C / 4
    arm_unit = Atoms(main_element + '4',
                     pbc=(1, 0, 1),
                     cell=[4 * b, 0, 3 * C_C])
    arm_unit.positions = [[0, 0, 0],
                          [b * 2, 0, C_C / 2.],
                          [b * 2, 0, 3 * C_C / 2.],
                          [0, 0, 2 * C_C]]
    arm_unit_half = Atoms(main_element + '2',
                          pbc=(1, 0, 1),
                          cell=[2 * b, 0, 3 * C_C])
    arm_unit_half.positions = [[b * 2, 0, C_C / 2.],
                               [b * 2, 0, 3 * C_C / 2.]]
    zz_unit = Atoms(main_element + '2',
                    pbc=(1, 0, 1),
                    cell=[3 * C_C / 2.0, 0, b * 4])
    zz_unit.positions = [[0, 0, 0],
                         [C_C / 2.0, 0, b * 2]]
    atoms = Atoms()

    if type == 'zigzag':
        edge_index0 = np.arange(m) * 2
        edge_index1 = (n - 1) * m * 2 + np.arange(m) * 2 + 1

        if magnetic:
            mms = np.zeros(m * n * 2)
            for i in edge_index0:
                mms[i] = initial_mag
            for i in edge_index1:
                mms[i] = -initial_mag

        for i in range(n):
            layer = zz_unit.repeat((1, 1, m))
            layer.positions[:, 0] += 3 * C_C / 2 * i
            if i % 2 == 1:
                layer.positions[:, 2] += 2 * b
                layer[-1].position[2] -= b * 4 * m
            atoms += layer

        xmin = atoms.positions[0, 0]

        if magnetic:
            atoms.set_initial_magnetic_moments(mms)
        if saturated:
            H_atoms0 = Atoms(saturate_element + str(m))
            H_atoms0.positions = atoms[edge_index0].positions
            H_atoms0.positions[:, 0] -= C_H
            H_atoms1 = Atoms(saturate_element + str(m))
            H_atoms1.positions = atoms[edge_index1].positions
            H_atoms1.positions[:, 0] += C_H
            atoms += H_atoms0 + H_atoms1
        atoms.cell = [n * 3 * C_C / 2, 0, m * 4 * b]

    elif type == 'armchair':
        n *= 2
        n_int = int(round(n))
        if abs(n_int - n) > 1e-10:
            raise ValueError(
                'The argument n has to be half-integer for armchair ribbons.')
        n = n_int

        for i in range(n // 2):
            layer = arm_unit.repeat((1, 1, m))
            layer.positions[:, 0] -= 4 * b * i
            atoms += layer
        if n % 2:
            layer = arm_unit_half.repeat((1, 1, m))
            layer.positions[:, 0] -= 4 * b * (n // 2)
            atoms += layer

        xmin = atoms.positions[-1, 0]

        if saturated:
            if n % 2:
                arm_right_saturation = Atoms(saturate_element + '2',
                                             pbc=(1, 0, 1),
                                             cell=[2 * b, 0, 3 * C_C])
                arm_right_saturation.positions = [
                    [- sqrt(3) / 2 * C_H, 0, C_C / 2 - C_H * 0.5],
                    [- sqrt(3) / 2 * C_H, 0, 3 * C_C / 2.0 + C_H * 0.5]]
            else:
                arm_right_saturation = Atoms(saturate_element + '2',
                                             pbc=(1, 0, 1),
                                             cell=[4 * b, 0, 3 * C_C])
                arm_right_saturation.positions = [
                    [- sqrt(3) / 2 * C_H, 0, C_H * 0.5],
                    [- sqrt(3) / 2 * C_H, 0, 2 * C_C - C_H * 0.5]]
            arm_left_saturation = Atoms(saturate_element + '2', pbc=(1, 0, 1),
                                        cell=[4 * b, 0, 3 * C_C])
            arm_left_saturation.positions = [
                [b * 2 + sqrt(3) / 2 * C_H, 0, C_C / 2 - C_H * 0.5],
                [b * 2 + sqrt(3) / 2 * C_H, 0, 3 * C_C / 2.0 + C_H * 0.5]]
            arm_right_saturation.positions[:, 0] -= 4 * b * (n / 2.0 - 1)

            atoms += arm_right_saturation.repeat((1, 1, m))
            atoms += arm_left_saturation.repeat((1, 1, m))

        atoms.cell = [b * 4 * n / 2.0, 0, 3 * C_C * m]

    atoms.set_pbc([sheet, False, True])

    # The ribbon was 'built' from x=0 towards negative x.
    # Move the ribbon to positive x:
    atoms.positions[:, 0] -= xmin
    if not sheet:
        atoms.cell[0] = 0.0
    if vacuum is not None:
        atoms.center(vacuum, axis=1)
        if not sheet:
            atoms.center(vacuum, axis=0)
    return atoms



================================================
File: root.py
================================================
# fmt: off

from math import atan2, cos, log10, sin

import numpy as np


def hcp0001_root(symbol, root, size, a=None, c=None,
                 vacuum=None, orthogonal=False):
    """HCP(0001) surface maniupulated to have a x unit side length
    of *root* before repeating.  This also results in *root* number
    of repetitions of the cell.


    The first 20 valid roots for nonorthogonal are...
    1, 3, 4, 7, 9, 12, 13, 16, 19, 21, 25,
    27, 28, 31, 36, 37, 39, 43, 48, 49"""
    from ase.build import hcp0001
    atoms = hcp0001(symbol=symbol, size=(1, 1, size[2]),
                    a=a, c=c, vacuum=vacuum, orthogonal=orthogonal)
    atoms = root_surface(atoms, root)
    atoms *= (size[0], size[1], 1)
    return atoms


def fcc111_root(symbol, root, size, a=None,
                vacuum=None, orthogonal=False):
    """FCC(111) surface maniupulated to have a x unit side length
    of *root* before repeating. This also results in *root* number
    of repetitions of the cell.

    The first 20 valid roots for nonorthogonal are...
    1, 3, 4, 7, 9, 12, 13, 16, 19, 21, 25, 27,
    28, 31, 36, 37, 39, 43, 48, 49"""
    from ase.build import fcc111
    atoms = fcc111(symbol=symbol, size=(1, 1, size[2]),
                   a=a, vacuum=vacuum, orthogonal=orthogonal)
    atoms = root_surface(atoms, root)
    atoms *= (size[0], size[1], 1)
    return atoms


def bcc111_root(symbol, root, size, a=None,
                vacuum=None, orthogonal=False):
    """BCC(111) surface maniupulated to have a x unit side length
    of *root* before repeating. This also results in *root* number
    of repetitions of the cell.


    The first 20 valid roots for nonorthogonal are...
    1, 3, 4, 7, 9, 12, 13, 16, 19, 21, 25,
    27, 28, 31, 36, 37, 39, 43, 48, 49"""
    from ase.build import bcc111
    atoms = bcc111(symbol=symbol, size=(1, 1, size[2]),
                   a=a, vacuum=vacuum, orthogonal=orthogonal)
    atoms = root_surface(atoms, root)
    atoms *= (size[0], size[1], 1)
    return atoms


def point_in_cell_2d(point, cell, eps=1e-8):
    """This function takes a 2D slice of the cell in the XY plane and calculates
    if a point should lie in it.  This is used as a more accurate method of
    ensuring we find all of the correct cell repetitions in the root surface
    code.  The Z axis is totally ignored but for most uses this should be fine.
    """
    # Define area of a triangle
    def tri_area(t1, t2, t3):
        t1x, t1y = t1[0:2]
        t2x, t2y = t2[0:2]
        t3x, t3y = t3[0:2]
        return abs(t1x * (t2y - t3y) + t2x *
                   (t3y - t1y) + t3x * (t1y - t2y)) / 2

    # c0, c1, c2, c3 define a parallelogram
    c0 = (0, 0)
    c1 = cell[0, 0:2]
    c2 = cell[1, 0:2]
    c3 = c1 + c2

    # Get area of parallelogram
    cA = tri_area(c0, c1, c2) + tri_area(c1, c2, c3)

    # Get area of triangles formed from adjacent vertices of parallelogram and
    # point in question.
    pA = tri_area(point, c0, c1) + tri_area(point, c1, c2) + \
        tri_area(point, c2, c3) + tri_area(point, c3, c0)

    # If combined area of triangles from point is larger than area of
    # parallelogram, point is not inside parallelogram.
    return pA <= cA + eps


def _root_cell_normalization(primitive_slab):
    """Returns the scaling factor for x axis and cell normalized by that
    factor"""

    xscale = np.linalg.norm(primitive_slab.cell[0, 0:2])
    cell_vectors = primitive_slab.cell[0:2, 0:2] / xscale
    return xscale, cell_vectors


def _root_surface_analysis(primitive_slab, root, eps=1e-8):
    """A tool to analyze a slab and look for valid roots that exist, up to
    the given root. This is useful for generating all possible cells
    without prior knowledge.

    *primitive slab* is the primitive cell to analyze.

    *root* is the desired root to find, and all below.

    This is the internal function which gives extra data to root_surface.
    """

    # Setup parameters for cell searching
    logeps = int(-log10(eps))
    _xscale, cell_vectors = _root_cell_normalization(primitive_slab)

    # Allocate grid for cell search search
    points = np.indices((root + 1, root + 1)).T.reshape(-1, 2)

    # Find points corresponding to full cells
    cell_points = [cell_vectors[0] * x + cell_vectors[1] * y for x, y in points]

    # Find point close to the desired cell (floating point error possible)
    roots = np.around(np.linalg.norm(cell_points, axis=1)**2, logeps)

    valid_roots = np.nonzero(roots == root)[0]
    if len(valid_roots) == 0:
        raise ValueError(
            "Invalid root {} for cell {}".format(
                root, cell_vectors))
    int_roots = np.array([int(this_root) for this_root in roots
                          if this_root.is_integer() and this_root <= root])
    return cell_points, cell_points[np.nonzero(
        roots == root)[0][0]], set(int_roots[1:])


def root_surface_analysis(primitive_slab, root, eps=1e-8):
    """A tool to analyze a slab and look for valid roots that exist, up to
    the given root. This is useful for generating all possible cells
    without prior knowledge.

    *primitive slab* is the primitive cell to analyze.

    *root* is the desired root to find, and all below."""
    return _root_surface_analysis(
        primitive_slab=primitive_slab, root=root, eps=eps)[2]


def root_surface(primitive_slab, root, eps=1e-8):
    """Creates a cell from a primitive cell that repeats along the x and y
    axis in a way consisent with the primitive cell, that has been cut
    to have a side length of *root*.

    *primitive cell* should be a primitive 2d cell of your slab, repeated
    as needed in the z direction.

    *root* should be determined using an analysis tool such as the
    root_surface_analysis function, or prior knowledge. It should always
    be a whole number as it represents the number of repetitions."""

    atoms = primitive_slab.copy()

    xscale, cell_vectors = _root_cell_normalization(primitive_slab)

    # Do root surface analysis
    cell_points, root_point, _roots = _root_surface_analysis(
        primitive_slab, root, eps=eps)

    # Find new cell
    root_angle = -atan2(root_point[1], root_point[0])
    root_rotation = [[cos(root_angle), -sin(root_angle)],
                     [sin(root_angle), cos(root_angle)]]
    root_scale = np.linalg.norm(root_point)

    cell = np.array([np.dot(x, root_rotation) *
                    root_scale for x in cell_vectors])

    # Find all cell centers within the cell
    shift = cell_vectors.sum(axis=0) / 2
    cell_points = [
        point for point in cell_points if point_in_cell_2d(
            point + shift, cell, eps=eps)]

    # Setup new cell
    atoms.rotate(root_angle, v="z")
    atoms *= (root, root, 1)
    atoms.cell[0:2, 0:2] = cell * xscale
    atoms.center()

    # Remove all extra atoms
    del atoms[[atom.index for atom in atoms if not point_in_cell_2d(
        atom.position, atoms.cell, eps=eps)]]

    # Rotate cell back to original orientation
    standard_rotation = [[cos(-root_angle), -sin(-root_angle), 0],
                         [sin(-root_angle), cos(-root_angle), 0],
                         [0, 0, 1]]

    new_cell = np.array([np.dot(x, standard_rotation) for x in atoms.cell])
    new_positions = np.array([np.dot(x, standard_rotation)
                              for x in atoms.positions])

    atoms.cell = new_cell
    atoms.positions = new_positions
    return atoms



================================================
File: rotate.py
================================================
# fmt: off

import numpy as np

from ase.geometry import find_mic


def rotation_matrix_from_points(m0, m1):
    """Returns a rigid transformation/rotation matrix that minimizes the
    RMSD between two set of points.

    m0 and m1 should be (3, npoints) numpy arrays with
    coordinates as columns::

        (x1  x2   x3   ... xN
         y1  y2   y3   ... yN
         z1  z2   z3   ... zN)

    The centeroids should be set to origin prior to
    computing the rotation matrix.

    The rotation matrix is computed using quaternion
    algebra as detailed in::

        Melander et al. J. Chem. Theory Comput., 2015, 11,1055
    """

    v0 = np.copy(m0)
    v1 = np.copy(m1)

    # compute the rotation quaternion

    R11, R22, R33 = np.sum(v0 * v1, axis=1)
    R12, R23, R31 = np.sum(v0 * np.roll(v1, -1, axis=0), axis=1)
    R13, R21, R32 = np.sum(v0 * np.roll(v1, -2, axis=0), axis=1)

    f = [[R11 + R22 + R33, R23 - R32, R31 - R13, R12 - R21],
         [R23 - R32, R11 - R22 - R33, R12 + R21, R13 + R31],
         [R31 - R13, R12 + R21, -R11 + R22 - R33, R23 + R32],
         [R12 - R21, R13 + R31, R23 + R32, -R11 - R22 + R33]]

    F = np.array(f)

    w, V = np.linalg.eigh(F)
    # eigenvector corresponding to the most
    # positive eigenvalue
    q = V[:, np.argmax(w)]

    # Rotation matrix from the quaternion q

    R = quaternion_to_matrix(q)

    return R


def quaternion_to_matrix(q):
    """Returns a rotation matrix.

    Computed from a unit quaternion Input as (4,) numpy array.
    """

    q0, q1, q2, q3 = q
    R_q = [[q0**2 + q1**2 - q2**2 - q3**2,
            2 * (q1 * q2 - q0 * q3),
            2 * (q1 * q3 + q0 * q2)],
           [2 * (q1 * q2 + q0 * q3),
            q0**2 - q1**2 + q2**2 - q3**2,
            2 * (q2 * q3 - q0 * q1)],
           [2 * (q1 * q3 - q0 * q2),
            2 * (q2 * q3 + q0 * q1),
            q0**2 - q1**2 - q2**2 + q3**2]]
    return np.array(R_q)


def minimize_rotation_and_translation(target, atoms):
    """Minimize RMSD between atoms and target.

    Rotate and translate atoms to best match target. Disregards rotation if PBC
    are found. Does not accound for changes in the cell. For more details, see::

        Melander et al. J. Chem. Theory Comput., 2015, 11,1055
    """

    p = atoms.get_positions()
    p0 = target.get_positions()

    if sum(atoms.pbc) != 0:
        # maybe we can raise a warning about cell changes here since we don't
        # account for them?

        # is this the best form of *find_mic version to use?
        dp_min, _dp_len = find_mic(p - p0, cell=target.cell, pbc=target.pbc)

        # add displacement without net translation
        p = p0 + dp_min - np.mean(dp_min, axis=0)
        R = np.eye(3)  # null rotation

    # centeroids to origin
    c = np.mean(p, axis=0)
    p -= c
    c0 = np.mean(p0, axis=0)
    p0 -= c0

    if sum(atoms.pbc) == 0:
        # Compute rotation matrix
        R = rotation_matrix_from_points(p.T, p0.T)

    atoms.set_positions(np.dot(p, R.T) + c0)



================================================
File: supercells.py
================================================
# fmt: off

"""Helper functions for creating supercells."""

import numpy as np

from ase import Atoms
from ase.utils import deprecated


class SupercellError(Exception):
    """Use if construction of supercell fails"""


@deprecated('use `eval_length_deviation` instead.')
def get_deviation_from_optimal_cell_shape(*args, **kwargs):
    return eval_length_deviation(*args, **kwargs)


def eval_shape_deviation(cell, target_shape="sc"):
    r"""
    Calculates the deviation of the given cell from the target cell metric.

    Parameters
    ----------
    cell : (..., 3, 3) array_like
        Metric given as a 3x3 matrix of the input structure.
        Multiple cells can also be given as a higher-dimensional array.
    target_shape : {'sc', 'fcc'}
        Desired supercell shape.

    Returns
    -------
    float or ndarray
        Cell metric(s) (0 is perfect score)

    """

    cell = np.asarray(cell)

    eff_cubic_length = np.cbrt(np.abs(np.linalg.det(cell)))  # 'a_0'

    if target_shape == 'sc':
        target_len = eff_cubic_length
        target_cos = 0.0  # cos(+-pi/2) = 0.0
        target_metric = np.eye(3)
    elif target_shape == 'fcc':
        # FCC is characterised by 60 degree angles & lattice vectors = 2**(1/6)
        # times the eff cubic length:
        target_len = eff_cubic_length * 2 ** (1 / 6)
        target_cos = 0.5  # cos(+-pi/3) = 0.5
        target_metric = np.eye(3) + target_cos * (np.ones((3, 3)) - np.eye(3))
    else:
        raise ValueError(target_shape)

    # calculate cell @ cell.T for (... , 3, 3)
    # with cell  -> C_mij
    # and metric -> M_mkl
    # M_mkl = (sum_j C_mkj * C_mlj) / leff**2
    metric = cell @ np.swapaxes(cell, -2, -1)
    normed = metric / target_len[..., None, None] ** 2

    # offdiagonal ~ cos angle -> score = np.abs(cos angle - cos target_angle)
    scores = np.add.reduce((normed - target_metric) ** 2, axis=(-2, -1))

    return scores


def eval_length_deviation(cell, target_shape="sc"):
    r"""Calculate the deviation from the target cell shape.

    Calculates the deviation of the given cell metric from the ideal
    cell metric defining a certain shape. Specifically, the function
    evaluates the expression `\Delta = || Q \mathbf{h} -
    \mathbf{h}_{target}||_2`, where `\mathbf{h}` is the input
    metric (*cell*) and `Q` is a normalization factor (*norm*)
    while the target metric `\mathbf{h}_{target}` (via
    *target_shape*) represent simple cubic ('sc') or face-centered
    cubic ('fcc') cell shapes.

    Replaced with code from the `doped` defect simulation package
    (https://doped.readthedocs.io) to be rotationally invariant,
    boosting performance.

    Parameters
    ----------
    cell : (..., 3, 3) array_like
        Metric given as a 3x3 matrix of the input structure.
        Multiple cells can also be given as a higher-dimensional array.
    target_shape : {'sc', 'fcc'}
        Desired supercell shape. Can be 'sc' for simple cubic or
        'fcc' for face-centered cubic.

    Returns
    -------
    float or ndarray
        Cell metric(s) (0 is perfect score)

    .. deprecated:: 3.24.0
        `norm` is unused in ASE 3.24.0 and removed in ASE 3.25.0.

    """

    cell = np.asarray(cell)
    cell_lengths = np.sqrt(np.add.reduce(cell**2, axis=-1))

    eff_cubic_length = np.cbrt(np.abs(np.linalg.det(cell)))  # 'a_0'

    if target_shape == 'sc':
        target_len = eff_cubic_length

    elif target_shape == 'fcc':
        # FCC is characterised by 60 degree angles & lattice vectors = 2**(1/6)
        # times the eff cubic length:
        target_len = eff_cubic_length * 2 ** (1 / 6)

    else:
        raise ValueError(target_shape)

    inv_target_len = 1.0 / target_len

    # rms difference to eff cubic/FCC length:
    diffs = cell_lengths * inv_target_len[..., None] - 1.0
    scores = np.sqrt(np.add.reduce(diffs**2, axis=-1))

    return scores


def _guess_initial_transformation(cell, target_shape,
                                  target_size, verbose=False):

    # Set up target metric
    if target_shape == 'sc':
        target_metric = np.eye(3)
    elif target_shape == 'fcc':
        target_metric = 0.5 * np.array([[0, 1, 1], [1, 0, 1], [1, 1, 0]],
                                       dtype=float)
    else:
        raise ValueError(target_shape)

    if verbose:
        print("target metric (h_target):")
        print(target_metric)

    # Normalize cell metric to reduce computation time during looping
    norm = (target_size * abs(np.linalg.det(cell)) /
            np.linalg.det(target_metric)) ** (-1.0 / 3)
    norm_cell = norm * cell
    if verbose:
        print(f"normalization factor (Q): {norm:g}")

    # Approximate initial P matrix
    ideal_P = np.dot(target_metric, np.linalg.inv(norm_cell))
    if verbose:
        print("idealized transformation matrix:")
        print(ideal_P)
    starting_P = np.array(np.around(ideal_P, 0), dtype=int)
    if verbose:
        print("closest integer transformation matrix (P_0):")
        print(starting_P)

    return ideal_P, starting_P


def _build_matrix_operations(starting_P, lower_limit, upper_limit):
    mat_dim = starting_P.shape[0]

    if not mat_dim == starting_P.shape[1]:
        raise ValueError('Cell matrix should be quadratic.')

    # Build a big matrix of all admissible integer matrix operations.
    # (If this takes too much memory we could do blocking but there are
    # too many for looping one by one.)
    dimensions = [(upper_limit + 1) - lower_limit] * mat_dim**2
    operations = np.moveaxis(np.indices(dimensions), 0, -1)
    operations = operations.reshape(-1, mat_dim, mat_dim)
    operations += lower_limit  # Each element runs from lower to upper limits.
    operations += starting_P

    return operations


def _screen_supercell_size(operations, target_size):

    # screen supercells with the target size
    determinants = np.round(np.linalg.det(operations), 0).astype(int)
    good_indices = np.where(np.abs(determinants) == target_size)[0]

    if not good_indices.size:
        print("Failed to find a transformation matrix.")
        return None
    operations = operations[good_indices]

    return operations


def _optimal_transformation(operations, scores, ideal_P):

    imin = np.argmin(scores)
    best_score = scores[imin]
    # screen candidates with the same best score
    operations = operations[np.abs(scores - best_score) < 1e-6]

    # select the one whose cell orientation is the closest to the target
    # https://gitlab.com/ase/ase/-/merge_requests/3522
    imin = np.argmin(np.add.reduce((operations - ideal_P)**2, axis=(-2, -1)))

    optimal_P = operations[imin]

    if np.linalg.det(optimal_P) <= 0:
        optimal_P *= -1  # flip signs if negative determinant

    return optimal_P, best_score


all_score_funcs = {"length": eval_length_deviation,
                   "metric": eval_shape_deviation}


def find_optimal_cell_shape(
    cell,
    target_size,
    target_shape,
    lower_limit=-2,
    upper_limit=2,
    verbose=False,
    score_key='length'
):
    """Obtain the optimal transformation matrix for a supercell of target size
    and shape.

    Returns the transformation matrix that produces a supercell
    corresponding to *target_size* unit cells with metric *cell* that
    most closely approximates the shape defined by *target_shape*.

    Updated with code from the `doped` defect simulation package
    (https://doped.readthedocs.io) to be rotationally invariant and
    allow transformation matrices with negative determinants, boosting
    performance.

    Parameters:

    cell: 2D array of floats
        Metric given as a (3x3 matrix) of the input structure.
    target_size: integer
        Size of desired supercell in number of unit cells.
    target_shape: str
        Desired supercell shape. Can be 'sc' for simple cubic or
        'fcc' for face-centered cubic.
    lower_limit: int
        Lower limit of search range.
    upper_limit: int
        Upper limit of search range.
    verbose: bool
        Set to True to obtain additional information regarding
        construction of transformation matrix.
    score_key: str
        key from all_score_funcs to select score function.

    Returns:
        2D array of integers: Transformation matrix that produces the
        optimal supercell.
    """

    # transform to np.array
    cell = np.asarray(cell)

    # get starting transformation
    # ideal_P ... transformation: target_cell = ideal_P @ cell
    # starting_P ... integer rounded (ideal_P)
    ideal_P, starting_P = _guess_initial_transformation(cell, target_shape,
                                                        target_size,
                                                        verbose=verbose)

    # build all admissible matrix operations 'centered' at starting_P
    operations = _build_matrix_operations(starting_P,
                                          lower_limit, upper_limit)

    # pre-screen operations based on target_size
    operations = _screen_supercell_size(operations, target_size)

    # evaluate derivations of the screened supercells
    if score_key in all_score_funcs:
        get_deviation_score = all_score_funcs[score_key]
    else:
        msg = (f'Score func key {score_key} not implemented.'
               + f'Please select from {all_score_funcs}.')
        raise SupercellError(msg)

    scores = get_deviation_score(operations @ cell,
                                 target_shape)

    # obtain optimal transformation from scores
    optimal_P, best_score = _optimal_transformation(operations, scores, ideal_P)

    # Finalize.
    if verbose:
        print(f"smallest score (|Q P h_p - h_target|_2): {best_score:f}")
        print("optimal transformation matrix (P_opt):")
        print(optimal_P)
        print("supercell metric:")
        print(np.round(np.dot(optimal_P, cell), 4))
        det = np.linalg.det(optimal_P)
        print(f"determinant of optimal transformation matrix: {det:g}")

    return optimal_P


def make_supercell(prim, P, *, wrap=True, order="cell-major", tol=1e-5):
    r"""Generate a supercell by applying a general transformation (*P*) to
    the input configuration (*prim*).

    The transformation is described by a 3x3 integer matrix
    `\mathbf{P}`. Specifically, the new cell metric
    `\mathbf{h}` is given in terms of the metric of the input
    configuration `\mathbf{h}_p` by `\mathbf{P h}_p =
    \mathbf{h}`.

    Parameters:

    prim: ASE Atoms object
        Input configuration.
    P: 3x3 integer matrix
        Transformation matrix `\mathbf{P}`.
    wrap: bool
        wrap in the end
    order: str (default: "cell-major")
        how to order the atoms in the supercell

        "cell-major":
        [atom1_shift1, atom2_shift1, ..., atom1_shift2, atom2_shift2, ...]
        i.e. run first over all the atoms in cell1 and then move to cell2.

        "atom-major":
        [atom1_shift1, atom1_shift2, ..., atom2_shift1, atom2_shift2, ...]
        i.e. run first over atom1 in all the cells and then move to atom2.
        This may be the order preferred by most VASP users.

    tol: float
        tolerance for wrapping
    """

    supercell_matrix = P
    supercell = clean_matrix(supercell_matrix @ prim.cell)

    # cartesian lattice points
    lattice_points_frac = lattice_points_in_supercell(supercell_matrix)
    lattice_points = np.dot(lattice_points_frac, supercell)
    N = len(lattice_points)

    if order == "cell-major":
        shifted = prim.positions[None, :, :] + lattice_points[:, None, :]
    elif order == "atom-major":
        shifted = prim.positions[:, None, :] + lattice_points[None, :, :]
    else:
        raise ValueError(f"invalid order: {order}")
    shifted_reshaped = shifted.reshape(-1, 3)

    superatoms = Atoms(positions=shifted_reshaped,
                       cell=supercell,
                       pbc=prim.pbc)

    # Copy over any other possible arrays, inspired by atoms.__imul__
    for name, arr in prim.arrays.items():
        if name == "positions":
            # This was added during construction of the super cell
            continue
        shape = (N * arr.shape[0], *arr.shape[1:])
        if order == "cell-major":
            new_arr = np.repeat(arr[None, :], N, axis=0).reshape(shape)
        elif order == "atom-major":
            new_arr = np.repeat(arr[:, None], N, axis=1).reshape(shape)
        superatoms.set_array(name, new_arr)

    # check number of atoms is correct
    n_target = abs(int(np.round(np.linalg.det(supercell_matrix) * len(prim))))
    if n_target != len(superatoms):
        msg = "Number of atoms in supercell: {}, expected: {}".format(
            n_target, len(superatoms))
        raise SupercellError(msg)

    if wrap:
        superatoms.wrap(eps=tol)

    return superatoms


def lattice_points_in_supercell(supercell_matrix):
    """Find all lattice points contained in a supercell.

    Adapted from pymatgen, which is available under MIT license:
    The MIT License (MIT) Copyright (c) 2011-2012 MIT & The Regents of the
    University of California, through Lawrence Berkeley National Laboratory
    """

    diagonals = np.array([
        [0, 0, 0],
        [0, 0, 1],
        [0, 1, 0],
        [0, 1, 1],
        [1, 0, 0],
        [1, 0, 1],
        [1, 1, 0],
        [1, 1, 1],
    ])
    d_points = np.dot(diagonals, supercell_matrix)

    mins = np.min(d_points, axis=0)
    maxes = np.max(d_points, axis=0) + 1

    ar = np.arange(mins[0], maxes[0])[:, None] * np.array([1, 0, 0])[None, :]
    br = np.arange(mins[1], maxes[1])[:, None] * np.array([0, 1, 0])[None, :]
    cr = np.arange(mins[2], maxes[2])[:, None] * np.array([0, 0, 1])[None, :]

    all_points = ar[:, None, None] + br[None, :, None] + cr[None, None, :]
    all_points = all_points.reshape((-1, 3))

    frac_points = np.dot(all_points, np.linalg.inv(supercell_matrix))

    tvects = frac_points[np.all(frac_points < 1 - 1e-10, axis=1)
                         & np.all(frac_points >= -1e-10, axis=1)]
    assert len(tvects) == round(abs(np.linalg.det(supercell_matrix)))
    return tvects


def clean_matrix(matrix, eps=1e-12):
    """ clean from small values"""
    matrix = np.array(matrix)
    for ij in np.ndindex(matrix.shape):
        if abs(matrix[ij]) < eps:
            matrix[ij] = 0
    return matrix



================================================
File: surface.py
================================================
# fmt: off

"""Helper functions for creating the most common surfaces and related tasks.

The helper functions can create the most common low-index surfaces,
add vacuum layers and add adsorbates.

"""

from math import sqrt
from operator import itemgetter

import numpy as np

from ase.atom import Atom
from ase.atoms import Atoms
from ase.data import atomic_numbers, reference_states
from ase.lattice.cubic import FaceCenteredCubic


def fcc100(symbol, size, a=None, vacuum=None, orthogonal=True,
           periodic=False):
    """FCC(100) surface.

    Supported special adsorption sites: 'ontop', 'bridge', 'hollow'."""
    if not orthogonal:
        raise NotImplementedError("Can't do non-orthogonal cell yet!")

    return _surface(symbol, 'fcc', '100', size, a, None, vacuum,
                    periodic=periodic,
                    orthogonal=orthogonal)


def fcc110(symbol, size, a=None, vacuum=None, orthogonal=True,
           periodic=False):
    """FCC(110) surface.

    Supported special adsorption sites: 'ontop', 'longbridge',
    'shortbridge', 'hollow'."""
    if not orthogonal:
        raise NotImplementedError("Can't do non-orthogonal cell yet!")

    return _surface(symbol, 'fcc', '110', size, a, None, vacuum,
                    periodic=periodic,
                    orthogonal=orthogonal)


def bcc100(symbol, size, a=None, vacuum=None, orthogonal=True,
           periodic=False):
    """BCC(100) surface.

    Supported special adsorption sites: 'ontop', 'bridge', 'hollow'."""
    if not orthogonal:
        raise NotImplementedError("Can't do non-orthogonal cell yet!")

    return _surface(symbol, 'bcc', '100', size, a, None, vacuum,
                    periodic=periodic,
                    orthogonal=orthogonal)


def bcc110(symbol, size, a=None, vacuum=None, orthogonal=False,
           periodic=False):
    """BCC(110) surface.

    Supported special adsorption sites: 'ontop', 'longbridge',
    'shortbridge', 'hollow'.

    Use *orthogonal=True* to get an orthogonal unit cell - works only
    for size=(i,j,k) with j even."""
    return _surface(symbol, 'bcc', '110', size, a, None, vacuum,
                    periodic=periodic,
                    orthogonal=orthogonal)


def bcc111(symbol, size, a=None, vacuum=None, orthogonal=False,
           periodic=False):
    """BCC(111) surface.

    Supported special adsorption sites: 'ontop'.

    Use *orthogonal=True* to get an orthogonal unit cell - works only
    for size=(i,j,k) with j even."""
    return _surface(symbol, 'bcc', '111', size, a, None, vacuum,
                    periodic=periodic,
                    orthogonal=orthogonal)


def fcc111(symbol, size, a=None, vacuum=None, orthogonal=False,
           periodic=False):
    """FCC(111) surface.

    Supported special adsorption sites: 'ontop', 'bridge', 'fcc' and 'hcp'.

    Use *orthogonal=True* to get an orthogonal unit cell - works only
    for size=(i,j,k) with j even."""
    return _surface(symbol, 'fcc', '111', size, a, None, vacuum,
                    periodic=periodic,
                    orthogonal=orthogonal)


def hcp0001(symbol, size, a=None, c=None, vacuum=None, orthogonal=False,
            periodic=False):
    """HCP(0001) surface.

    Supported special adsorption sites: 'ontop', 'bridge', 'fcc' and 'hcp'.

    Use *orthogonal=True* to get an orthogonal unit cell - works only
    for size=(i,j,k) with j even."""
    return _surface(symbol, 'hcp', '0001', size, a, c, vacuum,
                    periodic=periodic,
                    orthogonal=orthogonal)


def hcp10m10(symbol, size, a=None, c=None, vacuum=None, orthogonal=True,
             periodic=False):
    """HCP(10m10) surface.

    Supported special adsorption sites: 'ontop'.

    Works only for size=(i,j,k) with j even."""
    if not orthogonal:
        raise NotImplementedError("Can't do non-orthogonal cell yet!")

    return _surface(symbol, 'hcp', '10m10', size, a, c, vacuum,
                    periodic=periodic,
                    orthogonal=orthogonal)


def diamond100(symbol, size, a=None, vacuum=None, orthogonal=True,
               periodic=False):
    """DIAMOND(100) surface.

    Supported special adsorption sites: 'ontop'."""
    if not orthogonal:
        raise NotImplementedError("Can't do non-orthogonal cell yet!")

    return _surface(symbol, 'diamond', '100', size, a, None, vacuum,
                    periodic=periodic,
                    orthogonal=orthogonal)


def diamond111(symbol, size, a=None, vacuum=None, orthogonal=False,
               periodic=False):
    """DIAMOND(111) surface.

    Supported special adsorption sites: 'ontop'."""

    if orthogonal:
        raise NotImplementedError("Can't do orthogonal cell yet!")
    return _surface(symbol, 'diamond', '111', size, a, None, vacuum,
                    periodic=periodic,
                    orthogonal=orthogonal)


def add_adsorbate(slab, adsorbate, height, position=(0, 0), offset=None,
                  mol_index=0):
    """Add an adsorbate to a surface.

    This function adds an adsorbate to a slab.  If the slab is
    produced by one of the utility functions in ase.build, it
    is possible to specify the position of the adsorbate by a keyword
    (the supported keywords depend on which function was used to
    create the slab).

    If the adsorbate is a molecule, the atom indexed by the mol_index
    optional argument is positioned on top of the adsorption position
    on the surface, and it is the responsibility of the user to orient
    the adsorbate in a sensible way.

    This function can be called multiple times to add more than one
    adsorbate.

    Parameters:

    slab: The surface onto which the adsorbate should be added.

    adsorbate:  The adsorbate. Must be one of the following three types:
        A string containing the chemical symbol for a single atom.
        An atom object.
        An atoms object (for a molecular adsorbate).

    height: Height above the surface.

    position: The x-y position of the adsorbate, either as a tuple of
        two numbers or as a keyword (if the surface is produced by one
        of the functions in ase.build).

    offset (default: None): Offsets the adsorbate by a number of unit
        cells. Mostly useful when adding more than one adsorbate.

    mol_index (default: 0): If the adsorbate is a molecule, index of
        the atom to be positioned above the location specified by the
        position argument.

    Note *position* is given in absolute xy coordinates (or as
    a keyword), whereas offset is specified in unit cells.  This
    can be used to give the positions in units of the unit cell by
    using *offset* instead.

    """
    info = slab.info.get('adsorbate_info', {})

    pos = np.array([0.0, 0.0])  # (x, y) part
    spos = np.array([0.0, 0.0])  # part relative to unit cell
    if offset is not None:
        spos += np.asarray(offset, float)

    if isinstance(position, str):
        # A site-name:
        if 'sites' not in info:
            raise TypeError('If the atoms are not made by an ' +
                            'ase.build function, ' +
                            'position cannot be a name.')
        if position not in info['sites']:
            raise TypeError(f'Adsorption site {position} not supported.')
        spos += info['sites'][position]
    else:
        pos += position

    if 'cell' in info:
        cell = info['cell']
    else:
        cell = slab.get_cell()[:2, :2]

    pos += np.dot(spos, cell)

    # Convert the adsorbate to an Atoms object
    if isinstance(adsorbate, Atoms):
        ads = adsorbate
    elif isinstance(adsorbate, Atom):
        ads = Atoms([adsorbate])
    else:
        # Assume it is a string representing a single Atom
        ads = Atoms([Atom(adsorbate)])

    # Get the z-coordinate:
    if 'top layer atom index' in info:
        a = info['top layer atom index']
    else:
        a = slab.positions[:, 2].argmax()
        if 'adsorbate_info' not in slab.info:
            slab.info['adsorbate_info'] = {}
        slab.info['adsorbate_info']['top layer atom index'] = a
    z = slab.positions[a, 2] + height

    # Move adsorbate into position
    ads.translate([pos[0], pos[1], z] - ads.positions[mol_index])

    # Attach the adsorbate
    slab.extend(ads)


def add_vacuum(atoms, vacuum):
    """Add vacuum layer to the atoms.

    Parameters:

    atoms: Atoms object
        Most likely created by one of the surface functions.
    vacuum: float
        The thickness of the vacuum layer (in Angstrom).
    """
    uc = atoms.get_cell()
    normal = np.cross(uc[0], uc[1])
    costheta = np.dot(normal, uc[2]) / np.sqrt(np.dot(normal, normal) *
                                               np.dot(uc[2], uc[2]))
    length = np.sqrt(np.dot(uc[2], uc[2]))
    newlength = length + vacuum / costheta
    uc[2] *= newlength / length
    atoms.set_cell(uc)


def create_tags(size) -> np.ndarray:
    """ Function to create layer tags. """
    # tag atoms by layer
    # create blocks of descending integers of length size[0]*size[1]
    return np.arange(size[2], 0, -1).repeat(size[0] * size[1])


def _surface(symbol, structure, face, size, a, c, vacuum, periodic,
             orthogonal=True):
    """Function to build often used surfaces.

    Don't call this function directly - use fcc100, fcc110, bcc111, ..."""

    Z = atomic_numbers[symbol]

    if a is None:
        sym = reference_states[Z]['symmetry']
        if sym != structure:
            raise ValueError(
                f"Can't guess lattice constant for {structure}-{symbol}!")
        a = reference_states[Z]['a']

    if structure == 'hcp' and c is None:
        if reference_states[Z]['symmetry'] == 'hcp':
            c = reference_states[Z]['c/a'] * a
        else:
            c = sqrt(8 / 3.0) * a

    positions = np.empty((size[2], size[1], size[0], 3))
    positions[..., 0] = np.arange(size[0]).reshape((1, 1, -1))
    positions[..., 1] = np.arange(size[1]).reshape((1, -1, 1))
    positions[..., 2] = np.arange(size[2]).reshape((-1, 1, 1))

    numbers = np.ones(size[0] * size[1] * size[2], int) * Z

    slab = Atoms(numbers,
                 tags=create_tags(size),
                 pbc=(True, True, periodic),
                 cell=size)

    surface_cell = None
    sites = {'ontop': (0, 0)}
    surf = structure + face
    if surf == 'fcc100':
        cell = (sqrt(0.5), sqrt(0.5), 0.5)
        positions[-2::-2, ..., :2] += 0.5
        sites.update({'hollow': (0.5, 0.5), 'bridge': (0.5, 0)})
    elif surf == 'diamond100':
        cell = (sqrt(0.5), sqrt(0.5), 0.5 / 2)
        positions[-4::-4, ..., :2] += (0.5, 0.5)
        positions[-3::-4, ..., :2] += (0.0, 0.5)
        positions[-2::-4, ..., :2] += (0.0, 0.0)
        positions[-1::-4, ..., :2] += (0.5, 0.0)
    elif surf == 'fcc110':
        cell = (1.0, sqrt(0.5), sqrt(0.125))
        positions[-2::-2, ..., :2] += 0.5
        sites.update({'hollow': (0.5, 0.5), 'longbridge': (0.5, 0),
                      'shortbridge': (0, 0.5)})
    elif surf == 'bcc100':
        cell = (1.0, 1.0, 0.5)
        positions[-2::-2, ..., :2] += 0.5
        sites.update({'hollow': (0.5, 0.5), 'bridge': (0.5, 0)})
    else:
        if orthogonal and size[1] % 2 == 1:
            raise ValueError(("Can't make orthorhombic cell with size=%r.  " %
                              (tuple(size),)) +
                             'Second number in size must be even.')
        if surf == 'fcc111':
            cell = (sqrt(0.5), sqrt(0.375), 1 / sqrt(3))
            if orthogonal:
                positions[-1::-3, 1::2, :, 0] += 0.5
                positions[-2::-3, 1::2, :, 0] += 0.5
                positions[-3::-3, 1::2, :, 0] -= 0.5
                positions[-2::-3, ..., :2] += (0.0, 2.0 / 3)
                positions[-3::-3, ..., :2] += (0.5, 1.0 / 3)
            else:
                positions[-2::-3, ..., :2] += (-1.0 / 3, 2.0 / 3)
                positions[-3::-3, ..., :2] += (1.0 / 3, 1.0 / 3)
            sites.update({'bridge': (0.5, 0), 'fcc': (1.0 / 3, 1.0 / 3),
                          'hcp': (2.0 / 3, 2.0 / 3)})
        elif surf == 'diamond111':
            cell = (sqrt(0.5), sqrt(0.375), 1 / sqrt(3) / 2)
            assert not orthogonal
            positions[-1::-6, ..., :3] += (0.0, 0.0, 0.5)
            positions[-2::-6, ..., :2] += (0.0, 0.0)
            positions[-3::-6, ..., :3] += (-1.0 / 3, 2.0 / 3, 0.5)
            positions[-4::-6, ..., :2] += (-1.0 / 3, 2.0 / 3)
            positions[-5::-6, ..., :3] += (1.0 / 3, 1.0 / 3, 0.5)
            positions[-6::-6, ..., :2] += (1.0 / 3, 1.0 / 3)
        elif surf == 'hcp0001':
            cell = (1.0, sqrt(0.75), 0.5 * c / a)
            if orthogonal:
                positions[:, 1::2, :, 0] += 0.5
                positions[-2::-2, ..., :2] += (0.0, 2.0 / 3)
            else:
                positions[-2::-2, ..., :2] += (-1.0 / 3, 2.0 / 3)
            sites.update({'bridge': (0.5, 0), 'fcc': (1.0 / 3, 1.0 / 3),
                          'hcp': (2.0 / 3, 2.0 / 3)})
        elif surf == 'hcp10m10':
            cell = (1.0, 0.5 * c / a, sqrt(0.75))
            assert orthogonal
            positions[-2::-2, ..., 0] += 0.5
            positions[:, ::2, :, 2] += 2.0 / 3
        elif surf == 'bcc110':
            cell = (1.0, sqrt(0.5), sqrt(0.5))
            if orthogonal:
                positions[:, 1::2, :, 0] += 0.5
                positions[-2::-2, ..., :2] += (0.0, 1.0)
            else:
                positions[-2::-2, ..., :2] += (-0.5, 1.0)
            sites.update({'shortbridge': (0, 0.5),
                          'longbridge': (0.5, 0),
                          'hollow': (0.375, 0.25)})
        elif surf == 'bcc111':
            cell = (sqrt(2), sqrt(1.5), sqrt(3) / 6)
            if orthogonal:
                positions[-1::-3, 1::2, :, 0] += 0.5
                positions[-2::-3, 1::2, :, 0] += 0.5
                positions[-3::-3, 1::2, :, 0] -= 0.5
                positions[-2::-3, ..., :2] += (0.0, 2.0 / 3)
                positions[-3::-3, ..., :2] += (0.5, 1.0 / 3)
            else:
                positions[-2::-3, ..., :2] += (-1.0 / 3, 2.0 / 3)
                positions[-3::-3, ..., :2] += (1.0 / 3, 1.0 / 3)
            sites.update({'hollow': (1.0 / 3, 1.0 / 3)})
        else:
            2 / 0

        surface_cell = a * np.array([(cell[0], 0),
                                     (cell[0] / 2, cell[1])])
        if not orthogonal:
            cell = np.array([(cell[0], 0, 0),
                             (cell[0] / 2, cell[1], 0),
                             (0, 0, cell[2])])

    if surface_cell is None:
        surface_cell = a * np.diag(cell[:2])

    if isinstance(cell, tuple):
        cell = np.diag(cell)

    slab.set_positions(positions.reshape((-1, 3)))
    slab.set_cell([a * v * n for v, n in zip(cell, size)], scale_atoms=True)

    if not periodic:
        slab.cell[2] = 0.0

    if vacuum is not None:
        slab.center(vacuum, axis=2)

    if 'adsorbate_info' not in slab.info:
        slab.info.update({'adsorbate_info': {}})

    slab.info['adsorbate_info']['cell'] = surface_cell
    slab.info['adsorbate_info']['sites'] = sites
    return slab


def fcc211(symbol, size, a=None, vacuum=None, orthogonal=True):
    """FCC(211) surface.

    Does not currently support special adsorption sites.

    Currently only implemented for *orthogonal=True* with size specified
    as (i, j, k), where i, j, and k are number of atoms in each direction.
    i must be divisible by 3 to accommodate the step width.
    """
    if not orthogonal:
        raise NotImplementedError('Only implemented for orthogonal '
                                  'unit cells.')
    if size[0] % 3 != 0:
        raise NotImplementedError('First dimension of size must be '
                                  'divisible by 3.')
    atoms = FaceCenteredCubic(symbol,
                              directions=[[1, -1, -1],
                                          [0, 2, -2],
                                          [2, 1, 1]],
                              miller=(None, None, (2, 1, 1)),
                              latticeconstant=a,
                              size=(1, 1, 1),
                              pbc=True)
    z = (size[2] + 1) // 2
    atoms = atoms.repeat((size[0] // 3, size[1], z))
    if size[2] % 2:  # Odd: remove bottom layer and shrink cell.
        remove_list = [atom.index for atom in atoms
                       if atom.z < atoms[1].z]
        del atoms[remove_list]
        dz = atoms[0].z
        atoms.translate((0., 0., -dz))
        atoms.cell[2][2] -= dz

    atoms.cell[2] = 0.0
    atoms.pbc[2] = False
    if vacuum:
        atoms.center(vacuum, axis=2)

    # Renumber systematically from top down.
    orders = [(atom.index, round(atom.x, 3), round(atom.y, 3),
               -round(atom.z, 3), atom.index) for atom in atoms]
    orders.sort(key=itemgetter(3, 1, 2))
    newatoms = atoms.copy()
    for index, order in enumerate(orders):
        newatoms[index].position = atoms[order[0]].position.copy()

    # Add empty 'sites' dictionary for consistency with other functions
    newatoms.info['adsorbate_info'] = {'sites': {}}
    return newatoms


def mx2(formula='MoS2', kind='2H', a=3.18, thickness=3.19,
        size=(1, 1, 1), vacuum=None):
    """Create three-layer 2D materials with hexagonal structure.

    This can be used for e.g. metal dichalcogenides :mol:`MX_2` 2D structures
    such as :mol:`MoS_2`.

    https://en.wikipedia.org/wiki/Transition_metal_dichalcogenide_monolayers

    Parameters
    ----------
    kind : {'2H', '1T'}, default: '2H'

        - '2H': mirror-plane symmetry
        - '1T': inversion symmetry
    """
    if kind == '2H':
        basis = [(0, 0, 0),
                 (2 / 3, 1 / 3, 0.5 * thickness),
                 (2 / 3, 1 / 3, -0.5 * thickness)]
    elif kind == '1T':
        basis = [(0, 0, 0),
                 (2 / 3, 1 / 3, 0.5 * thickness),
                 (1 / 3, 2 / 3, -0.5 * thickness)]
    else:
        raise ValueError('Structure not recognized:', kind)

    cell = [[a, 0, 0], [-a / 2, a * 3**0.5 / 2, 0], [0, 0, 0]]

    atoms = Atoms(formula, cell=cell, pbc=(1, 1, 0))
    atoms.set_scaled_positions(basis)
    if vacuum is not None:
        atoms.center(vacuum, axis=2)
    atoms = atoms.repeat(size)
    return atoms


def graphene(formula='C2', a=2.460, thickness=0.0,
             size=(1, 1, 1), vacuum=None):
    """Create a graphene monolayer structure.

    Parameters
    ----------
    thickness : float, default: 0.0
        Thickness of the layer; maybe for a buckled structure like silicene.
    """
    cell = [[a, 0, 0], [-a / 2, a * 3**0.5 / 2, 0], [0, 0, 0]]
    basis = [[0, 0, -0.5 * thickness], [2 / 3, 1 / 3, 0.5 * thickness]]
    atoms = Atoms(formula, cell=cell, pbc=(1, 1, 0))
    atoms.set_scaled_positions(basis)
    if vacuum is not None:
        atoms.center(vacuum, axis=2)
    atoms = atoms.repeat(size)
    return atoms


def _all_surface_functions():
    # Convenient for debugging.
    d = {
        func.__name__: func
        for func in [
            fcc100,
            fcc110,
            bcc100,
            bcc110,
            bcc111,
            fcc111,
            hcp0001,
            hcp10m10,
            diamond100,
            diamond111,
            fcc111,
            mx2,
            graphene,
        ]
    }
    return d



================================================
File: surfaces_with_termination.py
================================================
# fmt: off

import numpy as np

from ase.build.general_surface import surface
from ase.geometry import get_layers
from ase.symbols import string2symbols


def surfaces_with_termination(lattice, indices, layers, vacuum=None, tol=1e-10,
                              termination=None, return_all=False,
                              verbose=False):
    """Create surface from a given lattice and Miller indices with a given
        termination

        Parameters
        ==========
        lattice: Atoms object or str
            Bulk lattice structure of alloy or pure metal.  Note that the
            unit-cell must be the conventional cell - not the primitive cell.
            One can also give the chemical symbol as a string, in which case the
            correct bulk lattice will be generated automatically.
        indices: sequence of three int
            Surface normal in Miller indices (h,k,l).
        layers: int
            Number of equivalent layers of the slab. (not the same as the layers
            you choose from for terminations)
        vacuum: float
            Amount of vacuum added on both sides of the slab.
        termination: str
            the atoms you wish to be in the top layer. There may be many such
            terminations, this function returns all terminations with the same
            atomic composition.
            e.g. 'O' will return oxygen terminated surfaces.
            e.g.'TiO' returns surfaces terminated with layers containing both
            O and Ti
        Returns:
        return_surfs: List
            a list of surfaces that match the specifications given

    """
    lats = translate_lattice(lattice, indices)
    return_surfs = []
    check = []
    check2 = []
    for item in lats:
        too_similar = False
        surf = surface(item, indices, layers, vacuum=vacuum, tol=tol)
        surf.wrap(pbc=[True] * 3)  # standardize slabs

        positions = surf.get_scaled_positions().flatten()
        for i, value in enumerate(positions):
            if value >= 1 - tol:  # move things closer to zero within tol
                positions[i] -= 1
        surf.set_scaled_positions(np.reshape(positions, (len(surf), 3)))
        # rep = find_z_layers(surf)
        z_layers, _hs = get_layers(surf, (0, 0, 1))  # just z layers matter
        # get the indicies of the atoms in the highest layer
        top_layer = [
            i for i, val in enumerate(
                z_layers == max(z_layers)) if val]

        if termination is not None:
            comp = [surf.get_chemical_symbols()[a] for a in top_layer]
            term = string2symbols(termination)
            # list atoms in top layer and not in requested termination
            check = [a for a in comp if a not in term]
            # list of atoms in requested termination and not in top layer
            check2 = [a for a in term if a not in comp]
        if len(return_surfs) > 0:
            pos_diff = [a.get_positions() - surf.get_positions()
                        for a in return_surfs]
            for i, su in enumerate(pos_diff):
                similarity_test = su.flatten() < tol * 1000
                if similarity_test.all():
                    # checks if surface is too similar to another surface
                    too_similar = True
        if too_similar:
            continue
        if return_all is True:
            pass
        elif check != [] or check2 != []:
            continue
        return_surfs.append(surf)
    return return_surfs


def translate_lattice(lattice, indices, tol=10**-3):
    """translates a bulk unit cell along a normal vector given by the a set of
    miller indices to the next symetric position. This is used to control the
    termination of the surface in the smart_surface command
    Parameters:
    ==========
        lattice: Atoms object
            atoms object of the bulk unit cell
        indices: 1x3 list,tuple, or numpy array
            the miller indices you wish to cut along.
    returns:
        lattice_list: list of Atoms objects
            a list of all the different translations of the unit cell that will
            yield different terminations of a surface cut along the miller
            indices provided.
    """
    lattice_list = []
    cell = lattice.get_cell()
    pt = [0, 0, 0]
    h, k, l = indices  # noqa (E741 ambiguous name 'l')
    millers = list(indices)
    for index, item in enumerate(millers):
        if item == 0:
            millers[index] = 10**9  # make zeros large numbers
        elif pt == [0, 0, 0]:  # for numerical stability
            pt = list(cell[index] / float(item) / np.linalg.norm(cell[index]))
    h1, k1, l1 = millers
    N = np.array(cell[0] / h1 + cell[1] / k1 + cell[2] / l1)
    n = N / np.linalg.norm(N)  # making a unit vector normal to cut plane
    # finding distance from cut plan vector
    d = [np.round(np.dot(n, (a - pt)) * n, 5) for
         a in lattice.get_scaled_positions()]
    duplicates = []
    for i, item in enumerate(d):
        g = [True for a in d[i + 1:] if np.linalg.norm(a - item) < tol]
        if g != []:
            duplicates.append(i)
    duplicates.reverse()
    for i in duplicates:
        del d[i]
    # put distance to the plane at the end of the array
    for i, item in enumerate(d):
        d[i] = np.append(item,
                         np.dot(n, (lattice.get_scaled_positions()[i] - pt)))
    d = np.array(d)
    d = d[d[:, 3].argsort()]  # sort by distance to the plane
    d = [a[:3] for a in d]  # remove distance
    d = list(d)  # make it a list again
    for i in d:
        """
        The above method gives you the boundries of between terminations that
        will allow you to build a complete set of terminations. However, it
        does not return all the boundries. Thus you must check both above and
        below the boundary, and not stray too far from the boundary. If you move
        too far away, you risk hitting another boundary you did not find.
        """
        lattice1 = lattice.copy()
        displacement = (h * cell[0] + k * cell[1] + l * cell[2]) \
            * (i + 10 ** -8)
        lattice1.positions -= displacement
        lattice_list.append(lattice1)
        lattice1 = lattice.copy()
        displacement = (h * cell[0] + k * cell[1] + l * cell[2]) \
            * (i - 10 ** -8)
        lattice1.positions -= displacement
        lattice_list.append(lattice1)
    return lattice_list



================================================
File: tools.py
================================================
# fmt: off

import numpy as np

from ase.build.niggli import niggli_reduce_cell


def cut(atoms, a=(1, 0, 0), b=(0, 1, 0), c=None, clength=None,
        origo=(0, 0, 0), nlayers=None, extend=1.0, tolerance=0.01,
        maxatoms=None):
    """Cuts out a cell defined by *a*, *b*, *c* and *origo* from a
    sufficiently repeated copy of *atoms*.

    Typically, this function is used to create slabs of different
    sizes and orientations. The vectors *a*, *b* and *c* are in scaled
    coordinates and defines the returned cell and should normally be
    integer-valued in order to end up with a periodic
    structure. However, for systems with sub-translations, like fcc,
    integer multiples of 1/2 or 1/3 might also make sense for some
    directions (and will be treated correctly).

    Parameters:

    atoms: Atoms instance
        This should correspond to a repeatable unit cell.
    a: int | 3 floats
        The a-vector in scaled coordinates of the cell to cut out. If
        integer, the a-vector will be the scaled vector from *origo* to the
        atom with index *a*.
    b: int | 3 floats
        The b-vector in scaled coordinates of the cell to cut out. If
        integer, the b-vector will be the scaled vector from *origo* to the
        atom with index *b*.
    c: None | int | 3 floats
        The c-vector in scaled coordinates of the cell to cut out.
        if integer, the c-vector will be the scaled vector from *origo* to
        the atom with index *c*.
        If *None* it will be along cross(a, b) converted to real space
        and normalised with the cube root of the volume. Note that this
        in general is not perpendicular to a and b for non-cubic
        systems. For cubic systems however, this is redused to
        c = cross(a, b).
    clength: None | float
        If not None, the length of the c-vector will be fixed to
        *clength* Angstroms. Should not be used together with
        *nlayers*.
    origo: int | 3 floats
        Position of origo of the new cell in scaled coordinates. If
        integer, the position of the atom with index *origo* is used.
    nlayers: None | int
        If *nlayers* is not *None*, the returned cell will have
        *nlayers* atomic layers in the c-direction.
    extend: 1 or 3 floats
        The *extend* argument scales the effective cell in which atoms
        will be included. It must either be three floats or a single
        float scaling all 3 directions.  By setting to a value just
        above one, e.g. 1.05, it is possible to all the corner and
        edge atoms in the returned cell.  This will of cause make the
        returned cell non-repeatable, but is very useful for
        visualisation.
    tolerance: float
        Determines what is defined as a plane.  All atoms within
        *tolerance* Angstroms from a given plane will be considered to
        belong to that plane.
    maxatoms: None | int
        This option is used to auto-tune *tolerance* when *nlayers* is
        given for high zone axis systems.  For high zone axis one
        needs to reduce *tolerance* in order to distinguise the atomic
        planes, resulting in the more atoms will be added and
        eventually MemoryError.  A too small *tolerance*, on the other
        hand, might result in inproper splitting of atomic planes and
        that too few layers are returned.  If *maxatoms* is not None,
        *tolerance* will automatically be gradually reduced until
        *nlayers* atomic layers is obtained, when the number of atoms
        exceeds *maxatoms*.

    Example: Create an aluminium (111) slab with three layers.

    >>> import ase
    >>> from ase.spacegroup import crystal
    >>> from ase.build.tools import cut

    # First, a unit cell of Al
    >>> a = 4.05
    >>> aluminium = crystal('Al', [(0,0,0)], spacegroup=225,
    ...                     cellpar=[a, a, a, 90, 90, 90])

    # Then cut out the slab
    >>> al111 = cut(aluminium, (1,-1,0), (0,1,-1), nlayers=3)

    Example: Visualisation of the skutterudite unit cell

    >>> from ase.spacegroup import crystal
    >>> from ase.build.tools import cut

    # Again, create a skutterudite unit cell
    >>> a = 9.04
    >>> skutterudite = crystal(
    ...     ('Co', 'Sb'),
    ...     basis=[(0.25,0.25,0.25), (0.0, 0.335, 0.158)],
    ...     spacegroup=204,
    ...     cellpar=[a, a, a, 90, 90, 90])

    # Then use *origo* to put 'Co' at the corners and *extend* to
    # include all corner and edge atoms.
    >>> s = cut(skutterudite, origo=(0.25, 0.25, 0.25), extend=1.01)
    >>> ase.view(s)  # doctest:+SKIP
    """
    atoms = atoms.copy()
    cell = atoms.cell

    if isinstance(origo, int):
        origo = atoms.get_scaled_positions()[origo]
    origo = np.array(origo, dtype=float)

    scaled = (atoms.get_scaled_positions() - origo) % 1.0
    scaled %= 1.0   # needed to ensure that all numbers are *less* than one
    atoms.set_scaled_positions(scaled)

    if isinstance(a, int):
        a = scaled[a] - origo
    if isinstance(b, int):
        b = scaled[b] - origo
    if isinstance(c, int):
        c = scaled[c] - origo

    a = np.array(a, dtype=float)
    b = np.array(b, dtype=float)
    if c is None:
        metric = np.dot(cell, cell.T)
        vol = np.sqrt(np.linalg.det(metric))
        h = np.cross(a, b)
        H = np.linalg.solve(metric.T, h.T)
        c = vol * H / vol**(1. / 3.)
    c = np.array(c, dtype=float)

    if nlayers:
        # Recursive increase the length of c until we have at least
        # *nlayers* atomic layers parallel to the a-b plane
        while True:
            at = cut(atoms, a, b, c, origo=origo, extend=extend,
                     tolerance=tolerance)
            scaled = at.get_scaled_positions()
            d = scaled[:, 2]
            keys = np.argsort(d)
            ikeys = np.argsort(keys)
            tol = tolerance
            while True:
                mask = np.concatenate(([True], np.diff(d[keys]) > tol))
                tags = np.cumsum(mask)[ikeys] - 1
                levels = d[keys][mask]
                if (maxatoms is None or len(at) < maxatoms or
                        len(levels) > nlayers):
                    break
                tol *= 0.9
            if len(levels) > nlayers:
                break
            c *= 2

        at.cell[2] *= levels[nlayers]
        return at[tags < nlayers]

    newcell = np.dot(np.array([a, b, c]), cell)
    if nlayers is None and clength is not None:
        newcell[2, :] *= clength / np.linalg.norm(newcell[2])

    # Create a new atoms object, repeated and translated such that
    # it completely covers the new cell
    scorners_newcell = np.array([[0., 0., 0.], [0., 0., 1.],
                                 [0., 1., 0.], [0., 1., 1.],
                                 [1., 0., 0.], [1., 0., 1.],
                                 [1., 1., 0.], [1., 1., 1.]])
    corners = np.dot(scorners_newcell, newcell * extend)
    scorners = np.linalg.solve(cell.T, corners.T).T
    rep = np.ceil(np.ptp(scorners, axis=0)).astype('int') + 1
    trans = np.dot(np.floor(scorners.min(axis=0)), cell)
    atoms = atoms.repeat(rep)
    atoms.translate(trans)
    atoms.set_cell(newcell)

    # Mask out atoms outside new cell
    stol = 0.1 * tolerance  # scaled tolerance, XXX
    maskcell = atoms.cell * extend
    sp = np.linalg.solve(maskcell.T, (atoms.positions).T).T
    mask = np.all(np.logical_and(-stol <= sp, sp < 1 - stol), axis=1)
    atoms = atoms[mask]
    return atoms


class IncompatibleCellError(ValueError):
    """Exception raised if stacking fails due to incompatible cells
    between *atoms1* and *atoms2*."""


def stack(atoms1, atoms2, axis=2, cell=None, fix=0.5,
          maxstrain=0.5, distance=None, reorder=False,
          output_strained=False):
    """Return a new Atoms instance with *atoms2* stacked on top of
    *atoms1* along the given axis. Periodicity in all directions is
    ensured.

    The size of the final cell is determined by *cell*, except
    that the length alongh *axis* will be the sum of
    *atoms1.cell[axis]* and *atoms2.cell[axis]*. If *cell* is None,
    it will be interpolated between *atoms1* and *atoms2*, where
    *fix* determines their relative weight. Hence, if *fix* equals
    zero, the final cell will be determined purely from *atoms1* and
    if *fix* equals one, it will be determined purely from
    *atoms2*.

    An ase.geometry.IncompatibleCellError exception is raised if the
    cells of *atoms1* and *atoms2* are incompatible, e.g. if the far
    corner of the unit cell of either *atoms1* or *atoms2* is
    displaced more than *maxstrain*. Setting *maxstrain* to None
    disables this check.

    If *distance* is not None, the size of the final cell, along the
    direction perpendicular to the interface, will be adjusted such
    that the distance between the closest atoms in *atoms1* and
    *atoms2* will be equal to *distance*. This option uses
    scipy.optimize.fmin() and hence require scipy to be installed.

    If *reorder* is True, then the atoms will be reordered such that
    all atoms with the same symbol will follow sequencially after each
    other, eg: 'Al2MnAl10Fe' -> 'Al12FeMn'.

    If *output_strained* is True, then the strained versions of
    *atoms1* and *atoms2* are returned in addition to the stacked
    structure.

    Example: Create an Ag(110)-Si(110) interface with three atomic layers
    on each side.

    >>> import ase
    >>> from ase.spacegroup import crystal
    >>> from ase.build.tools import cut, stack
    >>>
    >>> a_ag = 4.09
    >>> ag = crystal(['Ag'], basis=[(0,0,0)], spacegroup=225,
    ...              cellpar=[a_ag, a_ag, a_ag, 90., 90., 90.])
    >>> ag110 = cut(ag, (0, 0, 3), (-1.5, 1.5, 0), nlayers=3)
    >>>
    >>> a_si = 5.43
    >>> si = crystal(['Si'], basis=[(0,0,0)], spacegroup=227,
    ...              cellpar=[a_si, a_si, a_si, 90., 90., 90.])
    >>> si110 = cut(si, (0, 0, 2), (-1, 1, 0), nlayers=3)
    >>>
    >>> interface = stack(ag110, si110, maxstrain=1)
    >>> ase.view(interface)  # doctest: +SKIP
    >>>
    # Once more, this time adjusted such that the distance between
    # the closest Ag and Si atoms will be 2.3 Angstrom (requires scipy).
    >>> interface2 = stack(ag110, si110,
    ...                    maxstrain=1, distance=2.3)   # doctest:+ELLIPSIS
    Optimization terminated successfully.
        ...
    >>> ase.view(interface2)  # doctest: +SKIP
    """
    atoms1 = atoms1.copy()
    atoms2 = atoms2.copy()

    for atoms in [atoms1, atoms2]:
        if not atoms.cell[axis].any():
            atoms.center(vacuum=0.0, axis=axis)

    if (np.sign(np.linalg.det(atoms1.cell)) !=
            np.sign(np.linalg.det(atoms2.cell))):
        raise IncompatibleCellError('Cells of *atoms1* and *atoms2* must have '
                                    'same handedness.')

    c1 = np.linalg.norm(atoms1.cell[axis])
    c2 = np.linalg.norm(atoms2.cell[axis])
    if cell is None:
        cell1 = atoms1.cell.copy()
        cell2 = atoms2.cell.copy()
        cell1[axis] /= c1
        cell2[axis] /= c2
        cell = cell1 + fix * (cell2 - cell1)
    cell[axis] /= np.linalg.norm(cell[axis])
    cell1 = cell.copy()
    cell2 = cell.copy()
    cell1[axis] *= c1
    cell2[axis] *= c2

    if maxstrain:
        strain1 = np.sqrt(((cell1 - atoms1.cell).sum(axis=0)**2).sum())
        strain2 = np.sqrt(((cell2 - atoms2.cell).sum(axis=0)**2).sum())
        if strain1 > maxstrain or strain2 > maxstrain:
            raise IncompatibleCellError(
                '*maxstrain* exceeded. *atoms1* strained %f and '
                '*atoms2* strained %f.' % (strain1, strain2))

    atoms1.set_cell(cell1, scale_atoms=True)
    atoms2.set_cell(cell2, scale_atoms=True)
    if output_strained:
        atoms1_strained = atoms1.copy()
        atoms2_strained = atoms2.copy()

    if distance is not None:
        from scipy.optimize import fmin

        def mindist(pos1, pos2):
            n1 = len(pos1)
            n2 = len(pos2)
            idx1 = np.arange(n1).repeat(n2)
            idx2 = np.tile(np.arange(n2), n1)
            return np.sqrt(((pos1[idx1] - pos2[idx2])**2).sum(axis=1).min())

        def func(x):
            t1, t2, h1, h2 = x[0:3], x[3:6], x[6], x[7]
            pos1 = atoms1.positions + t1
            pos2 = atoms2.positions + t2
            d1 = mindist(pos1, pos2 + (h1 + 1.0) * atoms1.cell[axis])
            d2 = mindist(pos2, pos1 + (h2 + 1.0) * atoms2.cell[axis])
            return (d1 - distance)**2 + (d2 - distance)**2

        atoms1.center()
        atoms2.center()
        x0 = np.zeros((8,))
        x = fmin(func, x0)
        t1, t2, h1, h2 = x[0:3], x[3:6], x[6], x[7]
        atoms1.translate(t1)
        atoms2.translate(t2)
        atoms1.cell[axis] *= 1.0 + h1
        atoms2.cell[axis] *= 1.0 + h2

    atoms2.translate(atoms1.cell[axis])
    atoms1.cell[axis] += atoms2.cell[axis]
    atoms1.extend(atoms2)

    if reorder:
        atoms1 = sort(atoms1)

    if output_strained:
        return atoms1, atoms1_strained, atoms2_strained
    else:
        return atoms1


def rotation_matrix(a1, a2, b1, b2):
    """Returns a rotation matrix that rotates the vectors *a1* in the
    direction of *a2* and *b1* in the direction of *b2*.

    In the case that the angle between *a2* and *b2* is not the same
    as between *a1* and *b1*, a proper rotation matrix will anyway be
    constructed by first rotate *b2* in the *b1*, *b2* plane.
    """
    a1 = np.asarray(a1, dtype=float) / np.linalg.norm(a1)
    b1 = np.asarray(b1, dtype=float) / np.linalg.norm(b1)
    c1 = np.cross(a1, b1)
    c1 /= np.linalg.norm(c1)      # clean out rounding errors...

    a2 = np.asarray(a2, dtype=float) / np.linalg.norm(a2)
    b2 = np.asarray(b2, dtype=float) / np.linalg.norm(b2)
    c2 = np.cross(a2, b2)
    c2 /= np.linalg.norm(c2)      # clean out rounding errors...

    # Calculate rotated *b2*
    theta = np.arccos(np.dot(a2, b2)) - np.arccos(np.dot(a1, b1))
    b3 = np.sin(theta) * a2 + np.cos(theta) * b2
    b3 /= np.linalg.norm(b3)      # clean out rounding errors...

    A1 = np.array([a1, b1, c1])
    A2 = np.array([a2, b3, c2])
    R = np.linalg.solve(A1, A2).T
    return R


def rotate(atoms, a1, a2, b1, b2, rotate_cell=True, center=(0, 0, 0)):
    """Rotate *atoms*, such that *a1* will be rotated in the direction
    of *a2* and *b1* in the direction of *b2*.  The point at *center*
    is fixed.  Use *center='COM'* to fix the center of mass.  If
    *rotate_cell* is true, the cell will be rotated together with the
    atoms.

    Note that the 000-corner of the cell is by definition fixed at
    origo.  Hence, setting *center* to something other than (0, 0, 0)
    will rotate the atoms out of the cell, even if *rotate_cell* is
    True.
    """
    if isinstance(center, str) and center.lower() == 'com':
        center = atoms.get_center_of_mass()

    R = rotation_matrix(a1, a2, b1, b2)
    atoms.positions[:] = np.dot(atoms.positions - center, R.T) + center

    if rotate_cell:
        atoms.cell[:] = np.dot(atoms.cell, R.T)


def minimize_tilt_ij(atoms, modified=1, fixed=0, fold_atoms=True):
    """Minimize the tilt angle for two given axes.

    The problem is underdetermined. Therefore one can choose one axis
    that is kept fixed.
    """

    orgcell_cc = atoms.get_cell()
    pbc_c = atoms.get_pbc()
    i = fixed
    j = modified
    if not (pbc_c[i] and pbc_c[j]):
        raise RuntimeError('Axes have to be periodic')

    prod_cc = np.dot(orgcell_cc, orgcell_cc.T)
    cell_cc = 1. * orgcell_cc
    nji = np.floor(- prod_cc[i, j] / prod_cc[i, i] + 0.5)
    cell_cc[j] = orgcell_cc[j] + nji * cell_cc[i]

    # sanity check
    def volume(cell):
        return np.abs(np.dot(cell[2], np.cross(cell[0], cell[1])))
    V = volume(cell_cc)
    assert abs(volume(orgcell_cc) - V) / V < 1.e-10

    atoms.set_cell(cell_cc)

    if fold_atoms:
        atoms.wrap()


def minimize_tilt(atoms, order=range(3), fold_atoms=True):
    """Minimize the tilt angles of the unit cell."""
    pbc_c = atoms.get_pbc()

    for i1, c1 in enumerate(order):
        for c2 in order[i1 + 1:]:
            if pbc_c[c1] and pbc_c[c2]:
                minimize_tilt_ij(atoms, c1, c2, fold_atoms)


def update_cell_and_positions(atoms, new_cell, op):
    """Helper method for transforming cell and positions of atoms object."""
    scpos = np.linalg.solve(op, atoms.get_scaled_positions().T).T

    # We do this twice because -1e-20 % 1 == 1:
    scpos[:, atoms.pbc] %= 1.0
    scpos[:, atoms.pbc] %= 1.0

    atoms.set_cell(new_cell)
    atoms.set_scaled_positions(scpos)


def niggli_reduce(atoms):
    """Convert the supplied atoms object's unit cell into its
    maximally-reduced Niggli unit cell. Even if the unit cell is already
    maximally reduced, it will be converted into its unique Niggli unit cell.
    This will also wrap all atoms into the new unit cell.

    References:

    Niggli, P. "Krystallographische und strukturtheoretische Grundbegriffe.
    Handbuch der Experimentalphysik", 1928, Vol. 7, Part 1, 108-176.

    Krivy, I. and Gruber, B., "A Unified Algorithm for Determining the
    Reduced (Niggli) Cell", Acta Cryst. 1976, A32, 297-298.

    Grosse-Kunstleve, R.W.; Sauter, N. K.; and Adams, P. D. "Numerically
    stable algorithms for the computation of reduced unit cells", Acta Cryst.
    2004, A60, 1-6.
    """
    from ase.geometry.geometry import permute_axes

    # Make sure non-periodic cell vectors are orthogonal
    non_periodic_cv = atoms.cell[~atoms.pbc]
    periodic_cv = atoms.cell[atoms.pbc]
    if not np.isclose(np.dot(non_periodic_cv, periodic_cv.T), 0).all():
        raise ValueError('Non-orthogonal cell along non-periodic dimensions')

    input_atoms = atoms

    # Permute axes, such that the non-periodic are along the last dimensions,
    # since niggli_reduce_cell will change the order of axes.
    permutation = np.argsort(~atoms.pbc)
    ipermutation = np.empty_like(permutation)
    ipermutation[permutation] = np.arange(len(permutation))
    atoms = permute_axes(atoms, permutation)

    # Perform the Niggli reduction on the cell
    nonpbc = ~atoms.pbc
    uncompleted_cell = atoms.cell.uncomplete(atoms.pbc)
    new_cell, op = niggli_reduce_cell(uncompleted_cell)
    new_cell[nonpbc] = atoms.cell[nonpbc]
    update_cell_and_positions(atoms, new_cell, op)

    # Undo the prior permutation.
    atoms = permute_axes(atoms, ipermutation)
    input_atoms.cell[:] = atoms.cell
    input_atoms.positions[:] = atoms.positions


def reduce_lattice(atoms, eps=2e-4):
    """Reduce atoms object to canonical lattice.

    This changes the cell and positions such that the atoms object has
    the canonical form used for defining band paths but is otherwise
    physically equivalent.  The eps parameter is used as a tolerance
    for determining the cell's Bravais lattice."""
    from ase.lattice import identify_lattice
    niggli_reduce(atoms)
    lat, op = identify_lattice(atoms.cell, eps=eps)
    update_cell_and_positions(atoms, lat.tocell(), np.linalg.inv(op))


def sort(atoms, tags=None):
    """Return a new Atoms object with sorted atomic order. The default
    is to order according to chemical symbols, but if *tags* is not
    None, it will be used instead. A stable sorting algorithm is used.

    Example:

    >>> from ase.build import bulk
    >>> from ase.build.tools import sort
    >>> # Two unit cells of NaCl:
    >>> a = 5.64
    >>> nacl = bulk('NaCl', 'rocksalt', a=a) * (2, 1, 1)
    >>> nacl.get_chemical_symbols()
    ['Na', 'Cl', 'Na', 'Cl']
    >>> nacl_sorted = sort(nacl)
    >>> nacl_sorted.get_chemical_symbols()
    ['Cl', 'Cl', 'Na', 'Na']
    >>> np.all(nacl_sorted.cell == nacl.cell)
    True
    """
    if tags is None:
        tags = atoms.get_chemical_symbols()
    else:
        tags = list(tags)
    deco = sorted([(tag, i) for i, tag in enumerate(tags)])
    indices = [i for tag, i in deco]
    return atoms[indices]



================================================
File: tube.py
================================================
# fmt: off

from math import gcd, sqrt

import numpy as np

from ase.atoms import Atoms


def nanotube(n, m, length=1, bond=1.42, symbol='C', verbose=False,
             vacuum=None):
    """Create an atomic structure.

    Creates a single-walled nanotube whose structure is specified using the
    standardized (n, m) notation.

    Parameters
    ----------
    n : int
        n in the (n, m) notation.
    m : int
        m in the (n, m) notation.
    length : int, optional
        Length (axial repetitions) of the nanotube.
    bond : float, optional
        Bond length between neighboring atoms.
    symbol : str, optional
        Chemical element to construct the nanotube from.
    verbose : bool, optional
        If True, will display key geometric parameters.

    Returns
    -------
    ase.atoms.Atoms
        An ASE Atoms object corresponding to the specified molecule.

    Examples
    --------
    >>> from ase.build import nanotube
    >>> atoms1 = nanotube(6, 0, length=4)
    >>> atoms2 = nanotube(3, 3, length=6, bond=1.4, symbol='Si')
    """
    if n < m:
        m, n = n, m
        sign = -1
    else:
        sign = 1

    nk = 6000
    sq3 = sqrt(3.0)
    a = sq3 * bond
    l2 = n * n + m * m + n * m
    l1 = sqrt(l2)

    nd = gcd(n, m)
    if (n - m) % (3 * nd) == 0:
        ndr = 3 * nd
    else:
        ndr = nd

    nr = (2 * m + n) // ndr
    ns = -(2 * n + m) // ndr
    nn = 2 * l2 // ndr

    ichk = 0
    if nr == 0:
        n60 = 1
    else:
        n60 = nr * 4

    absn = abs(n60)
    nnp = []
    nnq = []
    for i in range(-absn, absn + 1):
        for j in range(-absn, absn + 1):
            j2 = nr * j - ns * i
            if j2 == 1:
                j1 = m * i - n * j
                if j1 > 0 and j1 < nn:
                    ichk += 1
                    nnp.append(i)
                    nnq.append(j)

    if ichk == 0:
        raise RuntimeError('not found p, q strange!!')
    if ichk >= 2:
        raise RuntimeError('more than 1 pair p, q strange!!')

    nnnp = nnp[0]
    nnnq = nnq[0]

    if verbose:
        print('the symmetry vector is', nnnp, nnnq)

    lp = nnnp * nnnp + nnnq * nnnq + nnnp * nnnq
    r = a * sqrt(lp)
    c = a * l1
    t = sq3 * c / ndr

    if 2 * nn > nk:
        raise RuntimeError('parameter nk is too small!')

    rs = c / (2.0 * np.pi)

    if verbose:
        print('radius=', rs, t)

    q1 = np.arctan((sq3 * m) / (2 * n + m))
    q2 = np.arctan((sq3 * nnnq) / (2 * nnnp + nnnq))
    q3 = q1 - q2

    q4 = 2.0 * np.pi / nn
    q5 = bond * np.cos((np.pi / 6.0) - q1) / c * 2.0 * np.pi

    h1 = abs(t) / abs(np.sin(q3))
    h2 = bond * np.sin((np.pi / 6.0) - q1)

    ii = 0
    x, y, z = [], [], []
    for i in range(nn):
        x1, y1, z1 = 0, 0, 0

        k = np.floor(i * abs(r) / h1)
        x1 = rs * np.cos(i * q4)
        y1 = rs * np.sin(i * q4)
        z1 = (i * abs(r) - k * h1) * np.sin(q3)
        kk2 = abs(np.floor((z1 + 0.0001) / t))
        if z1 >= t - 0.0001:
            z1 -= t * kk2
        elif z1 < 0:
            z1 += t * kk2
        ii += 1

        x.append(x1)
        y.append(y1)
        z.append(z1)
        z3 = (i * abs(r) - k * h1) * np.sin(q3) - h2
        ii += 1

        if z3 >= 0 and z3 < t:
            x2 = rs * np.cos(i * q4 + q5)
            y2 = rs * np.sin(i * q4 + q5)
            z2 = (i * abs(r) - k * h1) * np.sin(q3) - h2
            x.append(x2)
            y.append(y2)
            z.append(z2)
        else:
            x2 = rs * np.cos(i * q4 + q5)
            y2 = rs * np.sin(i * q4 + q5)
            z2 = (i * abs(r) - (k + 1) * h1) * np.sin(q3) - h2
            kk = abs(np.floor(z2 / t))
            if z2 >= t - 0.0001:
                z2 -= t * kk
            elif z2 < 0:
                z2 += t * kk
            x.append(x2)
            y.append(y2)
            z.append(z2)

    ntotal = 2 * nn
    X = []
    for i in range(ntotal):
        X.append([x[i], y[i], sign * z[i]])

    if length > 1:
        xx = X[:]
        for mnp in range(2, length + 1):
            for i in range(len(xx)):
                X.append(xx[i][:2] + [xx[i][2] + (mnp - 1) * t])

    transvec = t
    numatom = ntotal * length
    diameter = rs * 2
    chiralangle = np.arctan((sq3 * n) / (2 * m + n)) / np.pi * 180

    cell = [[0, 0, 0], [0, 0, 0], [0, 0, length * t]]
    atoms = Atoms(symbol + str(numatom),
                  positions=X,
                  cell=cell,
                  pbc=[False, False, True])
    if vacuum:
        atoms.center(vacuum, axis=(0, 1))
    if verbose:
        print('translation vector =', transvec)
        print('diameter = ', diameter)
        print('chiral angle = ', chiralangle)
    return atoms


